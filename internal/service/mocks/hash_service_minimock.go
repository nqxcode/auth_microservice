// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/nqxcode/auth_microservice/internal/service.HashService -o hash_service_minimock.go -n HashServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HashServiceMock implements service.HashService
type HashServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheck          func(ctx context.Context, password string, hash string) (b1 bool)
	inspectFuncCheck   func(ctx context.Context, password string, hash string)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mHashServiceMockCheck

	funcGenerateSalt          func(ctx context.Context) (s1 string, err error)
	inspectFuncGenerateSalt   func(ctx context.Context)
	afterGenerateSaltCounter  uint64
	beforeGenerateSaltCounter uint64
	GenerateSaltMock          mHashServiceMockGenerateSalt

	funcHash          func(ctx context.Context, password string) (s1 string, err error)
	inspectFuncHash   func(ctx context.Context, password string)
	afterHashCounter  uint64
	beforeHashCounter uint64
	HashMock          mHashServiceMockHash
}

// NewHashServiceMock returns a mock for service.HashService
func NewHashServiceMock(t minimock.Tester) *HashServiceMock {
	m := &HashServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckMock = mHashServiceMockCheck{mock: m}
	m.CheckMock.callArgs = []*HashServiceMockCheckParams{}

	m.GenerateSaltMock = mHashServiceMockGenerateSalt{mock: m}
	m.GenerateSaltMock.callArgs = []*HashServiceMockGenerateSaltParams{}

	m.HashMock = mHashServiceMockHash{mock: m}
	m.HashMock.callArgs = []*HashServiceMockHashParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHashServiceMockCheck struct {
	optional           bool
	mock               *HashServiceMock
	defaultExpectation *HashServiceMockCheckExpectation
	expectations       []*HashServiceMockCheckExpectation

	callArgs []*HashServiceMockCheckParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// HashServiceMockCheckExpectation specifies expectation struct of the HashService.Check
type HashServiceMockCheckExpectation struct {
	mock      *HashServiceMock
	params    *HashServiceMockCheckParams
	paramPtrs *HashServiceMockCheckParamPtrs
	results   *HashServiceMockCheckResults
	Counter   uint64
}

// HashServiceMockCheckParams contains parameters of the HashService.Check
type HashServiceMockCheckParams struct {
	ctx      context.Context
	password string
	hash     string
}

// HashServiceMockCheckParamPtrs contains pointers to parameters of the HashService.Check
type HashServiceMockCheckParamPtrs struct {
	ctx      *context.Context
	password *string
	hash     *string
}

// HashServiceMockCheckResults contains results of the HashService.Check
type HashServiceMockCheckResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheck *mHashServiceMockCheck) Optional() *mHashServiceMockCheck {
	mmCheck.optional = true
	return mmCheck
}

// Expect sets up expected params for HashService.Check
func (mmCheck *mHashServiceMockCheck) Expect(ctx context.Context, password string, hash string) *mHashServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &HashServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.paramPtrs != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by ExpectParams functions")
	}

	mmCheck.defaultExpectation.params = &HashServiceMockCheckParams{ctx, password, hash}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// ExpectCtxParam1 sets up expected param ctx for HashService.Check
func (mmCheck *mHashServiceMockCheck) ExpectCtxParam1(ctx context.Context) *mHashServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &HashServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &HashServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheck
}

// ExpectPasswordParam2 sets up expected param password for HashService.Check
func (mmCheck *mHashServiceMockCheck) ExpectPasswordParam2(password string) *mHashServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &HashServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &HashServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.password = &password

	return mmCheck
}

// ExpectHashParam3 sets up expected param hash for HashService.Check
func (mmCheck *mHashServiceMockCheck) ExpectHashParam3(hash string) *mHashServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &HashServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &HashServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.hash = &hash

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the HashService.Check
func (mmCheck *mHashServiceMockCheck) Inspect(f func(ctx context.Context, password string, hash string)) *mHashServiceMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for HashServiceMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by HashService.Check
func (mmCheck *mHashServiceMockCheck) Return(b1 bool) *HashServiceMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &HashServiceMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &HashServiceMockCheckResults{b1}
	return mmCheck.mock
}

// Set uses given function f to mock the HashService.Check method
func (mmCheck *mHashServiceMockCheck) Set(f func(ctx context.Context, password string, hash string) (b1 bool)) *HashServiceMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the HashService.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the HashService.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the HashService.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mHashServiceMockCheck) When(ctx context.Context, password string, hash string) *HashServiceMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("HashServiceMock.Check mock is already set by Set")
	}

	expectation := &HashServiceMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &HashServiceMockCheckParams{ctx, password, hash},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up HashService.Check return parameters for the expectation previously defined by the When method
func (e *HashServiceMockCheckExpectation) Then(b1 bool) *HashServiceMock {
	e.results = &HashServiceMockCheckResults{b1}
	return e.mock
}

// Times sets number of times HashService.Check should be invoked
func (mmCheck *mHashServiceMockCheck) Times(n uint64) *mHashServiceMockCheck {
	if n == 0 {
		mmCheck.mock.t.Fatalf("Times of HashServiceMock.Check mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheck.expectedInvocations, n)
	return mmCheck
}

func (mmCheck *mHashServiceMockCheck) invocationsDone() bool {
	if len(mmCheck.expectations) == 0 && mmCheck.defaultExpectation == nil && mmCheck.mock.funcCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheck.mock.afterCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Check implements service.HashService
func (mmCheck *HashServiceMock) Check(ctx context.Context, password string, hash string) (b1 bool) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(ctx, password, hash)
	}

	mm_params := HashServiceMockCheckParams{ctx, password, hash}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, &mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_want_ptrs := mmCheck.CheckMock.defaultExpectation.paramPtrs

		mm_got := HashServiceMockCheckParams{ctx, password, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheck.t.Errorf("HashServiceMock.Check got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmCheck.t.Errorf("HashServiceMock.Check got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmCheck.t.Errorf("HashServiceMock.Check got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("HashServiceMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the HashServiceMock.Check")
		}
		return (*mm_results).b1
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(ctx, password, hash)
	}
	mmCheck.t.Fatalf("Unexpected call to HashServiceMock.Check. %v %v %v", ctx, password, hash)
	return
}

// CheckAfterCounter returns a count of finished HashServiceMock.Check invocations
func (mmCheck *HashServiceMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of HashServiceMock.Check invocations
func (mmCheck *HashServiceMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to HashServiceMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mHashServiceMockCheck) Calls() []*HashServiceMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*HashServiceMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *HashServiceMock) MinimockCheckDone() bool {
	if m.CheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckMock.invocationsDone()
}

// MinimockCheckInspect logs each unmet expectation
func (m *HashServiceMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashServiceMock.Check with params: %#v", *e.params)
		}
	}

	afterCheckCounter := mm_atomic.LoadUint64(&m.afterCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && afterCheckCounter < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashServiceMock.Check")
		} else {
			m.t.Errorf("Expected call to HashServiceMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && afterCheckCounter < 1 {
		m.t.Error("Expected call to HashServiceMock.Check")
	}

	if !m.CheckMock.invocationsDone() && afterCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to HashServiceMock.Check but found %d calls",
			mm_atomic.LoadUint64(&m.CheckMock.expectedInvocations), afterCheckCounter)
	}
}

type mHashServiceMockGenerateSalt struct {
	optional           bool
	mock               *HashServiceMock
	defaultExpectation *HashServiceMockGenerateSaltExpectation
	expectations       []*HashServiceMockGenerateSaltExpectation

	callArgs []*HashServiceMockGenerateSaltParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// HashServiceMockGenerateSaltExpectation specifies expectation struct of the HashService.GenerateSalt
type HashServiceMockGenerateSaltExpectation struct {
	mock      *HashServiceMock
	params    *HashServiceMockGenerateSaltParams
	paramPtrs *HashServiceMockGenerateSaltParamPtrs
	results   *HashServiceMockGenerateSaltResults
	Counter   uint64
}

// HashServiceMockGenerateSaltParams contains parameters of the HashService.GenerateSalt
type HashServiceMockGenerateSaltParams struct {
	ctx context.Context
}

// HashServiceMockGenerateSaltParamPtrs contains pointers to parameters of the HashService.GenerateSalt
type HashServiceMockGenerateSaltParamPtrs struct {
	ctx *context.Context
}

// HashServiceMockGenerateSaltResults contains results of the HashService.GenerateSalt
type HashServiceMockGenerateSaltResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Optional() *mHashServiceMockGenerateSalt {
	mmGenerateSalt.optional = true
	return mmGenerateSalt
}

// Expect sets up expected params for HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Expect(ctx context.Context) *mHashServiceMockGenerateSalt {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	if mmGenerateSalt.defaultExpectation == nil {
		mmGenerateSalt.defaultExpectation = &HashServiceMockGenerateSaltExpectation{}
	}

	if mmGenerateSalt.defaultExpectation.paramPtrs != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by ExpectParams functions")
	}

	mmGenerateSalt.defaultExpectation.params = &HashServiceMockGenerateSaltParams{ctx}
	for _, e := range mmGenerateSalt.expectations {
		if minimock.Equal(e.params, mmGenerateSalt.defaultExpectation.params) {
			mmGenerateSalt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateSalt.defaultExpectation.params)
		}
	}

	return mmGenerateSalt
}

// ExpectCtxParam1 sets up expected param ctx for HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) ExpectCtxParam1(ctx context.Context) *mHashServiceMockGenerateSalt {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	if mmGenerateSalt.defaultExpectation == nil {
		mmGenerateSalt.defaultExpectation = &HashServiceMockGenerateSaltExpectation{}
	}

	if mmGenerateSalt.defaultExpectation.params != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Expect")
	}

	if mmGenerateSalt.defaultExpectation.paramPtrs == nil {
		mmGenerateSalt.defaultExpectation.paramPtrs = &HashServiceMockGenerateSaltParamPtrs{}
	}
	mmGenerateSalt.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGenerateSalt
}

// Inspect accepts an inspector function that has same arguments as the HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Inspect(f func(ctx context.Context)) *mHashServiceMockGenerateSalt {
	if mmGenerateSalt.mock.inspectFuncGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("Inspect function is already set for HashServiceMock.GenerateSalt")
	}

	mmGenerateSalt.mock.inspectFuncGenerateSalt = f

	return mmGenerateSalt
}

// Return sets up results that will be returned by HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Return(s1 string, err error) *HashServiceMock {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	if mmGenerateSalt.defaultExpectation == nil {
		mmGenerateSalt.defaultExpectation = &HashServiceMockGenerateSaltExpectation{mock: mmGenerateSalt.mock}
	}
	mmGenerateSalt.defaultExpectation.results = &HashServiceMockGenerateSaltResults{s1, err}
	return mmGenerateSalt.mock
}

// Set uses given function f to mock the HashService.GenerateSalt method
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Set(f func(ctx context.Context) (s1 string, err error)) *HashServiceMock {
	if mmGenerateSalt.defaultExpectation != nil {
		mmGenerateSalt.mock.t.Fatalf("Default expectation is already set for the HashService.GenerateSalt method")
	}

	if len(mmGenerateSalt.expectations) > 0 {
		mmGenerateSalt.mock.t.Fatalf("Some expectations are already set for the HashService.GenerateSalt method")
	}

	mmGenerateSalt.mock.funcGenerateSalt = f
	return mmGenerateSalt.mock
}

// When sets expectation for the HashService.GenerateSalt which will trigger the result defined by the following
// Then helper
func (mmGenerateSalt *mHashServiceMockGenerateSalt) When(ctx context.Context) *HashServiceMockGenerateSaltExpectation {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	expectation := &HashServiceMockGenerateSaltExpectation{
		mock:   mmGenerateSalt.mock,
		params: &HashServiceMockGenerateSaltParams{ctx},
	}
	mmGenerateSalt.expectations = append(mmGenerateSalt.expectations, expectation)
	return expectation
}

// Then sets up HashService.GenerateSalt return parameters for the expectation previously defined by the When method
func (e *HashServiceMockGenerateSaltExpectation) Then(s1 string, err error) *HashServiceMock {
	e.results = &HashServiceMockGenerateSaltResults{s1, err}
	return e.mock
}

// Times sets number of times HashService.GenerateSalt should be invoked
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Times(n uint64) *mHashServiceMockGenerateSalt {
	if n == 0 {
		mmGenerateSalt.mock.t.Fatalf("Times of HashServiceMock.GenerateSalt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateSalt.expectedInvocations, n)
	return mmGenerateSalt
}

func (mmGenerateSalt *mHashServiceMockGenerateSalt) invocationsDone() bool {
	if len(mmGenerateSalt.expectations) == 0 && mmGenerateSalt.defaultExpectation == nil && mmGenerateSalt.mock.funcGenerateSalt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateSalt.mock.afterGenerateSaltCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateSalt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateSalt implements service.HashService
func (mmGenerateSalt *HashServiceMock) GenerateSalt(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateSalt.beforeGenerateSaltCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateSalt.afterGenerateSaltCounter, 1)

	if mmGenerateSalt.inspectFuncGenerateSalt != nil {
		mmGenerateSalt.inspectFuncGenerateSalt(ctx)
	}

	mm_params := HashServiceMockGenerateSaltParams{ctx}

	// Record call args
	mmGenerateSalt.GenerateSaltMock.mutex.Lock()
	mmGenerateSalt.GenerateSaltMock.callArgs = append(mmGenerateSalt.GenerateSaltMock.callArgs, &mm_params)
	mmGenerateSalt.GenerateSaltMock.mutex.Unlock()

	for _, e := range mmGenerateSalt.GenerateSaltMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateSalt.GenerateSaltMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateSalt.GenerateSaltMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateSalt.GenerateSaltMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateSalt.GenerateSaltMock.defaultExpectation.paramPtrs

		mm_got := HashServiceMockGenerateSaltParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGenerateSalt.t.Errorf("HashServiceMock.GenerateSalt got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateSalt.t.Errorf("HashServiceMock.GenerateSalt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateSalt.GenerateSaltMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateSalt.t.Fatal("No results are set for the HashServiceMock.GenerateSalt")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateSalt.funcGenerateSalt != nil {
		return mmGenerateSalt.funcGenerateSalt(ctx)
	}
	mmGenerateSalt.t.Fatalf("Unexpected call to HashServiceMock.GenerateSalt. %v", ctx)
	return
}

// GenerateSaltAfterCounter returns a count of finished HashServiceMock.GenerateSalt invocations
func (mmGenerateSalt *HashServiceMock) GenerateSaltAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateSalt.afterGenerateSaltCounter)
}

// GenerateSaltBeforeCounter returns a count of HashServiceMock.GenerateSalt invocations
func (mmGenerateSalt *HashServiceMock) GenerateSaltBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateSalt.beforeGenerateSaltCounter)
}

// Calls returns a list of arguments used in each call to HashServiceMock.GenerateSalt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Calls() []*HashServiceMockGenerateSaltParams {
	mmGenerateSalt.mutex.RLock()

	argCopy := make([]*HashServiceMockGenerateSaltParams, len(mmGenerateSalt.callArgs))
	copy(argCopy, mmGenerateSalt.callArgs)

	mmGenerateSalt.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateSaltDone returns true if the count of the GenerateSalt invocations corresponds
// the number of defined expectations
func (m *HashServiceMock) MinimockGenerateSaltDone() bool {
	if m.GenerateSaltMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateSaltMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateSaltMock.invocationsDone()
}

// MinimockGenerateSaltInspect logs each unmet expectation
func (m *HashServiceMock) MinimockGenerateSaltInspect() {
	for _, e := range m.GenerateSaltMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashServiceMock.GenerateSalt with params: %#v", *e.params)
		}
	}

	afterGenerateSaltCounter := mm_atomic.LoadUint64(&m.afterGenerateSaltCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateSaltMock.defaultExpectation != nil && afterGenerateSaltCounter < 1 {
		if m.GenerateSaltMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashServiceMock.GenerateSalt")
		} else {
			m.t.Errorf("Expected call to HashServiceMock.GenerateSalt with params: %#v", *m.GenerateSaltMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateSalt != nil && afterGenerateSaltCounter < 1 {
		m.t.Error("Expected call to HashServiceMock.GenerateSalt")
	}

	if !m.GenerateSaltMock.invocationsDone() && afterGenerateSaltCounter > 0 {
		m.t.Errorf("Expected %d calls to HashServiceMock.GenerateSalt but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateSaltMock.expectedInvocations), afterGenerateSaltCounter)
	}
}

type mHashServiceMockHash struct {
	optional           bool
	mock               *HashServiceMock
	defaultExpectation *HashServiceMockHashExpectation
	expectations       []*HashServiceMockHashExpectation

	callArgs []*HashServiceMockHashParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// HashServiceMockHashExpectation specifies expectation struct of the HashService.Hash
type HashServiceMockHashExpectation struct {
	mock      *HashServiceMock
	params    *HashServiceMockHashParams
	paramPtrs *HashServiceMockHashParamPtrs
	results   *HashServiceMockHashResults
	Counter   uint64
}

// HashServiceMockHashParams contains parameters of the HashService.Hash
type HashServiceMockHashParams struct {
	ctx      context.Context
	password string
}

// HashServiceMockHashParamPtrs contains pointers to parameters of the HashService.Hash
type HashServiceMockHashParamPtrs struct {
	ctx      *context.Context
	password *string
}

// HashServiceMockHashResults contains results of the HashService.Hash
type HashServiceMockHashResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHash *mHashServiceMockHash) Optional() *mHashServiceMockHash {
	mmHash.optional = true
	return mmHash
}

// Expect sets up expected params for HashService.Hash
func (mmHash *mHashServiceMockHash) Expect(ctx context.Context, password string) *mHashServiceMockHash {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &HashServiceMockHashExpectation{}
	}

	if mmHash.defaultExpectation.paramPtrs != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by ExpectParams functions")
	}

	mmHash.defaultExpectation.params = &HashServiceMockHashParams{ctx, password}
	for _, e := range mmHash.expectations {
		if minimock.Equal(e.params, mmHash.defaultExpectation.params) {
			mmHash.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHash.defaultExpectation.params)
		}
	}

	return mmHash
}

// ExpectCtxParam1 sets up expected param ctx for HashService.Hash
func (mmHash *mHashServiceMockHash) ExpectCtxParam1(ctx context.Context) *mHashServiceMockHash {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &HashServiceMockHashExpectation{}
	}

	if mmHash.defaultExpectation.params != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Expect")
	}

	if mmHash.defaultExpectation.paramPtrs == nil {
		mmHash.defaultExpectation.paramPtrs = &HashServiceMockHashParamPtrs{}
	}
	mmHash.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHash
}

// ExpectPasswordParam2 sets up expected param password for HashService.Hash
func (mmHash *mHashServiceMockHash) ExpectPasswordParam2(password string) *mHashServiceMockHash {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &HashServiceMockHashExpectation{}
	}

	if mmHash.defaultExpectation.params != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Expect")
	}

	if mmHash.defaultExpectation.paramPtrs == nil {
		mmHash.defaultExpectation.paramPtrs = &HashServiceMockHashParamPtrs{}
	}
	mmHash.defaultExpectation.paramPtrs.password = &password

	return mmHash
}

// Inspect accepts an inspector function that has same arguments as the HashService.Hash
func (mmHash *mHashServiceMockHash) Inspect(f func(ctx context.Context, password string)) *mHashServiceMockHash {
	if mmHash.mock.inspectFuncHash != nil {
		mmHash.mock.t.Fatalf("Inspect function is already set for HashServiceMock.Hash")
	}

	mmHash.mock.inspectFuncHash = f

	return mmHash
}

// Return sets up results that will be returned by HashService.Hash
func (mmHash *mHashServiceMockHash) Return(s1 string, err error) *HashServiceMock {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &HashServiceMockHashExpectation{mock: mmHash.mock}
	}
	mmHash.defaultExpectation.results = &HashServiceMockHashResults{s1, err}
	return mmHash.mock
}

// Set uses given function f to mock the HashService.Hash method
func (mmHash *mHashServiceMockHash) Set(f func(ctx context.Context, password string) (s1 string, err error)) *HashServiceMock {
	if mmHash.defaultExpectation != nil {
		mmHash.mock.t.Fatalf("Default expectation is already set for the HashService.Hash method")
	}

	if len(mmHash.expectations) > 0 {
		mmHash.mock.t.Fatalf("Some expectations are already set for the HashService.Hash method")
	}

	mmHash.mock.funcHash = f
	return mmHash.mock
}

// When sets expectation for the HashService.Hash which will trigger the result defined by the following
// Then helper
func (mmHash *mHashServiceMockHash) When(ctx context.Context, password string) *HashServiceMockHashExpectation {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	expectation := &HashServiceMockHashExpectation{
		mock:   mmHash.mock,
		params: &HashServiceMockHashParams{ctx, password},
	}
	mmHash.expectations = append(mmHash.expectations, expectation)
	return expectation
}

// Then sets up HashService.Hash return parameters for the expectation previously defined by the When method
func (e *HashServiceMockHashExpectation) Then(s1 string, err error) *HashServiceMock {
	e.results = &HashServiceMockHashResults{s1, err}
	return e.mock
}

// Times sets number of times HashService.Hash should be invoked
func (mmHash *mHashServiceMockHash) Times(n uint64) *mHashServiceMockHash {
	if n == 0 {
		mmHash.mock.t.Fatalf("Times of HashServiceMock.Hash mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHash.expectedInvocations, n)
	return mmHash
}

func (mmHash *mHashServiceMockHash) invocationsDone() bool {
	if len(mmHash.expectations) == 0 && mmHash.defaultExpectation == nil && mmHash.mock.funcHash == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHash.mock.afterHashCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHash.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Hash implements service.HashService
func (mmHash *HashServiceMock) Hash(ctx context.Context, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmHash.beforeHashCounter, 1)
	defer mm_atomic.AddUint64(&mmHash.afterHashCounter, 1)

	if mmHash.inspectFuncHash != nil {
		mmHash.inspectFuncHash(ctx, password)
	}

	mm_params := HashServiceMockHashParams{ctx, password}

	// Record call args
	mmHash.HashMock.mutex.Lock()
	mmHash.HashMock.callArgs = append(mmHash.HashMock.callArgs, &mm_params)
	mmHash.HashMock.mutex.Unlock()

	for _, e := range mmHash.HashMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmHash.HashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHash.HashMock.defaultExpectation.Counter, 1)
		mm_want := mmHash.HashMock.defaultExpectation.params
		mm_want_ptrs := mmHash.HashMock.defaultExpectation.paramPtrs

		mm_got := HashServiceMockHashParams{ctx, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHash.t.Errorf("HashServiceMock.Hash got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmHash.t.Errorf("HashServiceMock.Hash got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHash.t.Errorf("HashServiceMock.Hash got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHash.HashMock.defaultExpectation.results
		if mm_results == nil {
			mmHash.t.Fatal("No results are set for the HashServiceMock.Hash")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmHash.funcHash != nil {
		return mmHash.funcHash(ctx, password)
	}
	mmHash.t.Fatalf("Unexpected call to HashServiceMock.Hash. %v %v", ctx, password)
	return
}

// HashAfterCounter returns a count of finished HashServiceMock.Hash invocations
func (mmHash *HashServiceMock) HashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHash.afterHashCounter)
}

// HashBeforeCounter returns a count of HashServiceMock.Hash invocations
func (mmHash *HashServiceMock) HashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHash.beforeHashCounter)
}

// Calls returns a list of arguments used in each call to HashServiceMock.Hash.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHash *mHashServiceMockHash) Calls() []*HashServiceMockHashParams {
	mmHash.mutex.RLock()

	argCopy := make([]*HashServiceMockHashParams, len(mmHash.callArgs))
	copy(argCopy, mmHash.callArgs)

	mmHash.mutex.RUnlock()

	return argCopy
}

// MinimockHashDone returns true if the count of the Hash invocations corresponds
// the number of defined expectations
func (m *HashServiceMock) MinimockHashDone() bool {
	if m.HashMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashMock.invocationsDone()
}

// MinimockHashInspect logs each unmet expectation
func (m *HashServiceMock) MinimockHashInspect() {
	for _, e := range m.HashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashServiceMock.Hash with params: %#v", *e.params)
		}
	}

	afterHashCounter := mm_atomic.LoadUint64(&m.afterHashCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashMock.defaultExpectation != nil && afterHashCounter < 1 {
		if m.HashMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashServiceMock.Hash")
		} else {
			m.t.Errorf("Expected call to HashServiceMock.Hash with params: %#v", *m.HashMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHash != nil && afterHashCounter < 1 {
		m.t.Error("Expected call to HashServiceMock.Hash")
	}

	if !m.HashMock.invocationsDone() && afterHashCounter > 0 {
		m.t.Errorf("Expected %d calls to HashServiceMock.Hash but found %d calls",
			mm_atomic.LoadUint64(&m.HashMock.expectedInvocations), afterHashCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HashServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckInspect()

			m.MinimockGenerateSaltInspect()

			m.MinimockHashInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HashServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HashServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckDone() &&
		m.MinimockGenerateSaltDone() &&
		m.MinimockHashDone()
}
