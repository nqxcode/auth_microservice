package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/nqxcode/auth_microservice/internal/service.HashService -o ./mocks\hash_service_minimock.go -n HashServiceMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HashServiceMock implements service.HashService
type HashServiceMock struct {
	t minimock.Tester

	funcGenerateSalt          func(ctx context.Context) (s1 string, err error)
	inspectFuncGenerateSalt   func(ctx context.Context)
	afterGenerateSaltCounter  uint64
	beforeGenerateSaltCounter uint64
	GenerateSaltMock          mHashServiceMockGenerateSalt

	funcHash          func(ctx context.Context, password string) (s1 string, err error)
	inspectFuncHash   func(ctx context.Context, password string)
	afterHashCounter  uint64
	beforeHashCounter uint64
	HashMock          mHashServiceMockHash
}

// NewHashServiceMock returns a mock for service.HashService
func NewHashServiceMock(t minimock.Tester) *HashServiceMock {
	m := &HashServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateSaltMock = mHashServiceMockGenerateSalt{mock: m}
	m.GenerateSaltMock.callArgs = []*HashServiceMockGenerateSaltParams{}

	m.HashMock = mHashServiceMockHash{mock: m}
	m.HashMock.callArgs = []*HashServiceMockHashParams{}

	return m
}

type mHashServiceMockGenerateSalt struct {
	mock               *HashServiceMock
	defaultExpectation *HashServiceMockGenerateSaltExpectation
	expectations       []*HashServiceMockGenerateSaltExpectation

	callArgs []*HashServiceMockGenerateSaltParams
	mutex    sync.RWMutex
}

// HashServiceMockGenerateSaltExpectation specifies expectation struct of the HashService.GenerateSalt
type HashServiceMockGenerateSaltExpectation struct {
	mock    *HashServiceMock
	params  *HashServiceMockGenerateSaltParams
	results *HashServiceMockGenerateSaltResults
	Counter uint64
}

// HashServiceMockGenerateSaltParams contains parameters of the HashService.GenerateSalt
type HashServiceMockGenerateSaltParams struct {
	ctx context.Context
}

// HashServiceMockGenerateSaltResults contains results of the HashService.GenerateSalt
type HashServiceMockGenerateSaltResults struct {
	s1  string
	err error
}

// Expect sets up expected params for HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Expect(ctx context.Context) *mHashServiceMockGenerateSalt {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	if mmGenerateSalt.defaultExpectation == nil {
		mmGenerateSalt.defaultExpectation = &HashServiceMockGenerateSaltExpectation{}
	}

	mmGenerateSalt.defaultExpectation.params = &HashServiceMockGenerateSaltParams{ctx}
	for _, e := range mmGenerateSalt.expectations {
		if minimock.Equal(e.params, mmGenerateSalt.defaultExpectation.params) {
			mmGenerateSalt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateSalt.defaultExpectation.params)
		}
	}

	return mmGenerateSalt
}

// Inspect accepts an inspector function that has same arguments as the HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Inspect(f func(ctx context.Context)) *mHashServiceMockGenerateSalt {
	if mmGenerateSalt.mock.inspectFuncGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("Inspect function is already set for HashServiceMock.GenerateSalt")
	}

	mmGenerateSalt.mock.inspectFuncGenerateSalt = f

	return mmGenerateSalt
}

// Return sets up results that will be returned by HashService.GenerateSalt
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Return(s1 string, err error) *HashServiceMock {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	if mmGenerateSalt.defaultExpectation == nil {
		mmGenerateSalt.defaultExpectation = &HashServiceMockGenerateSaltExpectation{mock: mmGenerateSalt.mock}
	}
	mmGenerateSalt.defaultExpectation.results = &HashServiceMockGenerateSaltResults{s1, err}
	return mmGenerateSalt.mock
}

// Set uses given function f to mock the HashService.GenerateSalt method
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Set(f func(ctx context.Context) (s1 string, err error)) *HashServiceMock {
	if mmGenerateSalt.defaultExpectation != nil {
		mmGenerateSalt.mock.t.Fatalf("Default expectation is already set for the HashService.GenerateSalt method")
	}

	if len(mmGenerateSalt.expectations) > 0 {
		mmGenerateSalt.mock.t.Fatalf("Some expectations are already set for the HashService.GenerateSalt method")
	}

	mmGenerateSalt.mock.funcGenerateSalt = f
	return mmGenerateSalt.mock
}

// When sets expectation for the HashService.GenerateSalt which will trigger the result defined by the following
// Then helper
func (mmGenerateSalt *mHashServiceMockGenerateSalt) When(ctx context.Context) *HashServiceMockGenerateSaltExpectation {
	if mmGenerateSalt.mock.funcGenerateSalt != nil {
		mmGenerateSalt.mock.t.Fatalf("HashServiceMock.GenerateSalt mock is already set by Set")
	}

	expectation := &HashServiceMockGenerateSaltExpectation{
		mock:   mmGenerateSalt.mock,
		params: &HashServiceMockGenerateSaltParams{ctx},
	}
	mmGenerateSalt.expectations = append(mmGenerateSalt.expectations, expectation)
	return expectation
}

// Then sets up HashService.GenerateSalt return parameters for the expectation previously defined by the When method
func (e *HashServiceMockGenerateSaltExpectation) Then(s1 string, err error) *HashServiceMock {
	e.results = &HashServiceMockGenerateSaltResults{s1, err}
	return e.mock
}

// GenerateSalt implements service.HashService
func (mmGenerateSalt *HashServiceMock) GenerateSalt(ctx context.Context) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateSalt.beforeGenerateSaltCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateSalt.afterGenerateSaltCounter, 1)

	if mmGenerateSalt.inspectFuncGenerateSalt != nil {
		mmGenerateSalt.inspectFuncGenerateSalt(ctx)
	}

	mm_params := &HashServiceMockGenerateSaltParams{ctx}

	// Record call args
	mmGenerateSalt.GenerateSaltMock.mutex.Lock()
	mmGenerateSalt.GenerateSaltMock.callArgs = append(mmGenerateSalt.GenerateSaltMock.callArgs, mm_params)
	mmGenerateSalt.GenerateSaltMock.mutex.Unlock()

	for _, e := range mmGenerateSalt.GenerateSaltMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateSalt.GenerateSaltMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateSalt.GenerateSaltMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateSalt.GenerateSaltMock.defaultExpectation.params
		mm_got := HashServiceMockGenerateSaltParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateSalt.t.Errorf("HashServiceMock.GenerateSalt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateSalt.GenerateSaltMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateSalt.t.Fatal("No results are set for the HashServiceMock.GenerateSalt")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateSalt.funcGenerateSalt != nil {
		return mmGenerateSalt.funcGenerateSalt(ctx)
	}
	mmGenerateSalt.t.Fatalf("Unexpected call to HashServiceMock.GenerateSalt. %v", ctx)
	return
}

// GenerateSaltAfterCounter returns a count of finished HashServiceMock.GenerateSalt invocations
func (mmGenerateSalt *HashServiceMock) GenerateSaltAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateSalt.afterGenerateSaltCounter)
}

// GenerateSaltBeforeCounter returns a count of HashServiceMock.GenerateSalt invocations
func (mmGenerateSalt *HashServiceMock) GenerateSaltBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateSalt.beforeGenerateSaltCounter)
}

// Calls returns a list of arguments used in each call to HashServiceMock.GenerateSalt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateSalt *mHashServiceMockGenerateSalt) Calls() []*HashServiceMockGenerateSaltParams {
	mmGenerateSalt.mutex.RLock()

	argCopy := make([]*HashServiceMockGenerateSaltParams, len(mmGenerateSalt.callArgs))
	copy(argCopy, mmGenerateSalt.callArgs)

	mmGenerateSalt.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateSaltDone returns true if the count of the GenerateSalt invocations corresponds
// the number of defined expectations
func (m *HashServiceMock) MinimockGenerateSaltDone() bool {
	for _, e := range m.GenerateSaltMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateSaltMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGenerateSaltCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateSalt != nil && mm_atomic.LoadUint64(&m.afterGenerateSaltCounter) < 1 {
		return false
	}
	return true
}

// MinimockGenerateSaltInspect logs each unmet expectation
func (m *HashServiceMock) MinimockGenerateSaltInspect() {
	for _, e := range m.GenerateSaltMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashServiceMock.GenerateSalt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateSaltMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGenerateSaltCounter) < 1 {
		if m.GenerateSaltMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashServiceMock.GenerateSalt")
		} else {
			m.t.Errorf("Expected call to HashServiceMock.GenerateSalt with params: %#v", *m.GenerateSaltMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateSalt != nil && mm_atomic.LoadUint64(&m.afterGenerateSaltCounter) < 1 {
		m.t.Error("Expected call to HashServiceMock.GenerateSalt")
	}
}

type mHashServiceMockHash struct {
	mock               *HashServiceMock
	defaultExpectation *HashServiceMockHashExpectation
	expectations       []*HashServiceMockHashExpectation

	callArgs []*HashServiceMockHashParams
	mutex    sync.RWMutex
}

// HashServiceMockHashExpectation specifies expectation struct of the HashService.Hash
type HashServiceMockHashExpectation struct {
	mock    *HashServiceMock
	params  *HashServiceMockHashParams
	results *HashServiceMockHashResults
	Counter uint64
}

// HashServiceMockHashParams contains parameters of the HashService.Hash
type HashServiceMockHashParams struct {
	ctx      context.Context
	password string
}

// HashServiceMockHashResults contains results of the HashService.Hash
type HashServiceMockHashResults struct {
	s1  string
	err error
}

// Expect sets up expected params for HashService.Hash
func (mmHash *mHashServiceMockHash) Expect(ctx context.Context, password string) *mHashServiceMockHash {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &HashServiceMockHashExpectation{}
	}

	mmHash.defaultExpectation.params = &HashServiceMockHashParams{ctx, password}
	for _, e := range mmHash.expectations {
		if minimock.Equal(e.params, mmHash.defaultExpectation.params) {
			mmHash.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHash.defaultExpectation.params)
		}
	}

	return mmHash
}

// Inspect accepts an inspector function that has same arguments as the HashService.Hash
func (mmHash *mHashServiceMockHash) Inspect(f func(ctx context.Context, password string)) *mHashServiceMockHash {
	if mmHash.mock.inspectFuncHash != nil {
		mmHash.mock.t.Fatalf("Inspect function is already set for HashServiceMock.Hash")
	}

	mmHash.mock.inspectFuncHash = f

	return mmHash
}

// Return sets up results that will be returned by HashService.Hash
func (mmHash *mHashServiceMockHash) Return(s1 string, err error) *HashServiceMock {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	if mmHash.defaultExpectation == nil {
		mmHash.defaultExpectation = &HashServiceMockHashExpectation{mock: mmHash.mock}
	}
	mmHash.defaultExpectation.results = &HashServiceMockHashResults{s1, err}
	return mmHash.mock
}

// Set uses given function f to mock the HashService.Hash method
func (mmHash *mHashServiceMockHash) Set(f func(ctx context.Context, password string) (s1 string, err error)) *HashServiceMock {
	if mmHash.defaultExpectation != nil {
		mmHash.mock.t.Fatalf("Default expectation is already set for the HashService.Hash method")
	}

	if len(mmHash.expectations) > 0 {
		mmHash.mock.t.Fatalf("Some expectations are already set for the HashService.Hash method")
	}

	mmHash.mock.funcHash = f
	return mmHash.mock
}

// When sets expectation for the HashService.Hash which will trigger the result defined by the following
// Then helper
func (mmHash *mHashServiceMockHash) When(ctx context.Context, password string) *HashServiceMockHashExpectation {
	if mmHash.mock.funcHash != nil {
		mmHash.mock.t.Fatalf("HashServiceMock.Hash mock is already set by Set")
	}

	expectation := &HashServiceMockHashExpectation{
		mock:   mmHash.mock,
		params: &HashServiceMockHashParams{ctx, password},
	}
	mmHash.expectations = append(mmHash.expectations, expectation)
	return expectation
}

// Then sets up HashService.Hash return parameters for the expectation previously defined by the When method
func (e *HashServiceMockHashExpectation) Then(s1 string, err error) *HashServiceMock {
	e.results = &HashServiceMockHashResults{s1, err}
	return e.mock
}

// Hash implements service.HashService
func (mmHash *HashServiceMock) Hash(ctx context.Context, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmHash.beforeHashCounter, 1)
	defer mm_atomic.AddUint64(&mmHash.afterHashCounter, 1)

	if mmHash.inspectFuncHash != nil {
		mmHash.inspectFuncHash(ctx, password)
	}

	mm_params := &HashServiceMockHashParams{ctx, password}

	// Record call args
	mmHash.HashMock.mutex.Lock()
	mmHash.HashMock.callArgs = append(mmHash.HashMock.callArgs, mm_params)
	mmHash.HashMock.mutex.Unlock()

	for _, e := range mmHash.HashMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmHash.HashMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHash.HashMock.defaultExpectation.Counter, 1)
		mm_want := mmHash.HashMock.defaultExpectation.params
		mm_got := HashServiceMockHashParams{ctx, password}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHash.t.Errorf("HashServiceMock.Hash got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHash.HashMock.defaultExpectation.results
		if mm_results == nil {
			mmHash.t.Fatal("No results are set for the HashServiceMock.Hash")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmHash.funcHash != nil {
		return mmHash.funcHash(ctx, password)
	}
	mmHash.t.Fatalf("Unexpected call to HashServiceMock.Hash. %v %v", ctx, password)
	return
}

// HashAfterCounter returns a count of finished HashServiceMock.Hash invocations
func (mmHash *HashServiceMock) HashAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHash.afterHashCounter)
}

// HashBeforeCounter returns a count of HashServiceMock.Hash invocations
func (mmHash *HashServiceMock) HashBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHash.beforeHashCounter)
}

// Calls returns a list of arguments used in each call to HashServiceMock.Hash.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHash *mHashServiceMockHash) Calls() []*HashServiceMockHashParams {
	mmHash.mutex.RLock()

	argCopy := make([]*HashServiceMockHashParams, len(mmHash.callArgs))
	copy(argCopy, mmHash.callArgs)

	mmHash.mutex.RUnlock()

	return argCopy
}

// MinimockHashDone returns true if the count of the Hash invocations corresponds
// the number of defined expectations
func (m *HashServiceMock) MinimockHashDone() bool {
	for _, e := range m.HashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHashCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHash != nil && mm_atomic.LoadUint64(&m.afterHashCounter) < 1 {
		return false
	}
	return true
}

// MinimockHashInspect logs each unmet expectation
func (m *HashServiceMock) MinimockHashInspect() {
	for _, e := range m.HashMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HashServiceMock.Hash with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HashMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHashCounter) < 1 {
		if m.HashMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HashServiceMock.Hash")
		} else {
			m.t.Errorf("Expected call to HashServiceMock.Hash with params: %#v", *m.HashMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHash != nil && mm_atomic.LoadUint64(&m.afterHashCounter) < 1 {
		m.t.Error("Expected call to HashServiceMock.Hash")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HashServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGenerateSaltInspect()

		m.MinimockHashInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HashServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HashServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateSaltDone() &&
		m.MinimockHashDone()
}
