// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/nqxcode/auth_microservice/internal/service.AuthService -o auth_service_minimock.go -n AuthServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/nqxcode/auth_microservice/internal/model"
	"github.com/nqxcode/platform_common/pagination"
)

// AuthServiceMock implements service.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheck          func(ctx context.Context, endpointAddress string) (b1 bool, err error)
	inspectFuncCheck   func(ctx context.Context, endpointAddress string)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mAuthServiceMockCheck

	funcCreate          func(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mAuthServiceMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mAuthServiceMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.User, err error)
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAuthServiceMockGet

	funcGetAccessToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	inspectFuncGetAccessToken   func(ctx context.Context, refreshToken string)
	afterGetAccessTokenCounter  uint64
	beforeGetAccessTokenCounter uint64
	GetAccessTokenMock          mAuthServiceMockGetAccessToken

	funcGetList          func(ctx context.Context, limit pagination.Limit) (ua1 []model.User, err error)
	inspectFuncGetList   func(ctx context.Context, limit pagination.Limit)
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mAuthServiceMockGetList

	funcGetRefreshToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	inspectFuncGetRefreshToken   func(ctx context.Context, refreshToken string)
	afterGetRefreshTokenCounter  uint64
	beforeGetRefreshTokenCounter uint64
	GetRefreshTokenMock          mAuthServiceMockGetRefreshToken

	funcLogin          func(ctx context.Context, email string, password string) (tp1 *model.TokenPair, err error)
	inspectFuncLogin   func(ctx context.Context, email string, password string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mAuthServiceMockLogin

	funcUpdate          func(ctx context.Context, id int64, info *model.UpdateUserInfo) (err error)
	inspectFuncUpdate   func(ctx context.Context, id int64, info *model.UpdateUserInfo)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mAuthServiceMockUpdate
}

// NewAuthServiceMock returns a mock for service.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckMock = mAuthServiceMockCheck{mock: m}
	m.CheckMock.callArgs = []*AuthServiceMockCheckParams{}

	m.CreateMock = mAuthServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*AuthServiceMockCreateParams{}

	m.DeleteMock = mAuthServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*AuthServiceMockDeleteParams{}

	m.GetMock = mAuthServiceMockGet{mock: m}
	m.GetMock.callArgs = []*AuthServiceMockGetParams{}

	m.GetAccessTokenMock = mAuthServiceMockGetAccessToken{mock: m}
	m.GetAccessTokenMock.callArgs = []*AuthServiceMockGetAccessTokenParams{}

	m.GetListMock = mAuthServiceMockGetList{mock: m}
	m.GetListMock.callArgs = []*AuthServiceMockGetListParams{}

	m.GetRefreshTokenMock = mAuthServiceMockGetRefreshToken{mock: m}
	m.GetRefreshTokenMock.callArgs = []*AuthServiceMockGetRefreshTokenParams{}

	m.LoginMock = mAuthServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*AuthServiceMockLoginParams{}

	m.UpdateMock = mAuthServiceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*AuthServiceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockCheck struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockCheckExpectation
	expectations       []*AuthServiceMockCheckExpectation

	callArgs []*AuthServiceMockCheckParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockCheckExpectation specifies expectation struct of the AuthService.Check
type AuthServiceMockCheckExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockCheckParams
	paramPtrs *AuthServiceMockCheckParamPtrs
	results   *AuthServiceMockCheckResults
	Counter   uint64
}

// AuthServiceMockCheckParams contains parameters of the AuthService.Check
type AuthServiceMockCheckParams struct {
	ctx             context.Context
	endpointAddress string
}

// AuthServiceMockCheckParamPtrs contains pointers to parameters of the AuthService.Check
type AuthServiceMockCheckParamPtrs struct {
	ctx             *context.Context
	endpointAddress *string
}

// AuthServiceMockCheckResults contains results of the AuthService.Check
type AuthServiceMockCheckResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheck *mAuthServiceMockCheck) Optional() *mAuthServiceMockCheck {
	mmCheck.optional = true
	return mmCheck
}

// Expect sets up expected params for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) Expect(ctx context.Context, endpointAddress string) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.paramPtrs != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by ExpectParams functions")
	}

	mmCheck.defaultExpectation.params = &AuthServiceMockCheckParams{ctx, endpointAddress}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &AuthServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheck
}

// ExpectEndpointAddressParam2 sets up expected param endpointAddress for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) ExpectEndpointAddressParam2(endpointAddress string) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &AuthServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.endpointAddress = &endpointAddress

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Check
func (mmCheck *mAuthServiceMockCheck) Inspect(f func(ctx context.Context, endpointAddress string)) *mAuthServiceMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by AuthService.Check
func (mmCheck *mAuthServiceMockCheck) Return(b1 bool, err error) *AuthServiceMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &AuthServiceMockCheckResults{b1, err}
	return mmCheck.mock
}

// Set uses given function f to mock the AuthService.Check method
func (mmCheck *mAuthServiceMockCheck) Set(f func(ctx context.Context, endpointAddress string) (b1 bool, err error)) *AuthServiceMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the AuthService.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the AuthService.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the AuthService.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mAuthServiceMockCheck) When(ctx context.Context, endpointAddress string) *AuthServiceMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	expectation := &AuthServiceMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &AuthServiceMockCheckParams{ctx, endpointAddress},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Check return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockCheckExpectation) Then(b1 bool, err error) *AuthServiceMock {
	e.results = &AuthServiceMockCheckResults{b1, err}
	return e.mock
}

// Times sets number of times AuthService.Check should be invoked
func (mmCheck *mAuthServiceMockCheck) Times(n uint64) *mAuthServiceMockCheck {
	if n == 0 {
		mmCheck.mock.t.Fatalf("Times of AuthServiceMock.Check mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheck.expectedInvocations, n)
	return mmCheck
}

func (mmCheck *mAuthServiceMockCheck) invocationsDone() bool {
	if len(mmCheck.expectations) == 0 && mmCheck.defaultExpectation == nil && mmCheck.mock.funcCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheck.mock.afterCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Check implements service.AuthService
func (mmCheck *AuthServiceMock) Check(ctx context.Context, endpointAddress string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(ctx, endpointAddress)
	}

	mm_params := AuthServiceMockCheckParams{ctx, endpointAddress}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, &mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_want_ptrs := mmCheck.CheckMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockCheckParams{ctx, endpointAddress}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.endpointAddress != nil && !minimock.Equal(*mm_want_ptrs.endpointAddress, mm_got.endpointAddress) {
				mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameter endpointAddress, want: %#v, got: %#v%s\n", *mm_want_ptrs.endpointAddress, mm_got.endpointAddress, minimock.Diff(*mm_want_ptrs.endpointAddress, mm_got.endpointAddress))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the AuthServiceMock.Check")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(ctx, endpointAddress)
	}
	mmCheck.t.Fatalf("Unexpected call to AuthServiceMock.Check. %v %v", ctx, endpointAddress)
	return
}

// CheckAfterCounter returns a count of finished AuthServiceMock.Check invocations
func (mmCheck *AuthServiceMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of AuthServiceMock.Check invocations
func (mmCheck *AuthServiceMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mAuthServiceMockCheck) Calls() []*AuthServiceMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*AuthServiceMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockCheckDone() bool {
	if m.CheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckMock.invocationsDone()
}

// MinimockCheckInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Check with params: %#v", *e.params)
		}
	}

	afterCheckCounter := mm_atomic.LoadUint64(&m.afterCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && afterCheckCounter < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Check")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && afterCheckCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Check")
	}

	if !m.CheckMock.invocationsDone() && afterCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Check but found %d calls",
			mm_atomic.LoadUint64(&m.CheckMock.expectedInvocations), afterCheckCounter)
	}
}

type mAuthServiceMockCreate struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockCreateExpectation
	expectations       []*AuthServiceMockCreateExpectation

	callArgs []*AuthServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockCreateExpectation specifies expectation struct of the AuthService.Create
type AuthServiceMockCreateExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockCreateParams
	paramPtrs *AuthServiceMockCreateParamPtrs
	results   *AuthServiceMockCreateResults
	Counter   uint64
}

// AuthServiceMockCreateParams contains parameters of the AuthService.Create
type AuthServiceMockCreateParams struct {
	ctx             context.Context
	info            *model.UserInfo
	password        string
	passwordConfirm string
}

// AuthServiceMockCreateParamPtrs contains pointers to parameters of the AuthService.Create
type AuthServiceMockCreateParamPtrs struct {
	ctx             *context.Context
	info            **model.UserInfo
	password        *string
	passwordConfirm *string
}

// AuthServiceMockCreateResults contains results of the AuthService.Create
type AuthServiceMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mAuthServiceMockCreate) Optional() *mAuthServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for AuthService.Create
func (mmCreate *mAuthServiceMockCreate) Expect(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string) *mAuthServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &AuthServiceMockCreateParams{ctx, info, password, passwordConfirm}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Create
func (mmCreate *mAuthServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &AuthServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectInfoParam2 sets up expected param info for AuthService.Create
func (mmCreate *mAuthServiceMockCreate) ExpectInfoParam2(info *model.UserInfo) *mAuthServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &AuthServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.info = &info

	return mmCreate
}

// ExpectPasswordParam3 sets up expected param password for AuthService.Create
func (mmCreate *mAuthServiceMockCreate) ExpectPasswordParam3(password string) *mAuthServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &AuthServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.password = &password

	return mmCreate
}

// ExpectPasswordConfirmParam4 sets up expected param passwordConfirm for AuthService.Create
func (mmCreate *mAuthServiceMockCreate) ExpectPasswordConfirmParam4(passwordConfirm string) *mAuthServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &AuthServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.passwordConfirm = &passwordConfirm

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Create
func (mmCreate *mAuthServiceMockCreate) Inspect(f func(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string)) *mAuthServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by AuthService.Create
func (mmCreate *mAuthServiceMockCreate) Return(i1 int64, err error) *AuthServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &AuthServiceMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the AuthService.Create method
func (mmCreate *mAuthServiceMockCreate) Set(f func(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string) (i1 int64, err error)) *AuthServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the AuthService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the AuthService.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the AuthService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mAuthServiceMockCreate) When(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string) *AuthServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthServiceMock.Create mock is already set by Set")
	}

	expectation := &AuthServiceMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &AuthServiceMockCreateParams{ctx, info, password, passwordConfirm},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Create return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockCreateExpectation) Then(i1 int64, err error) *AuthServiceMock {
	e.results = &AuthServiceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times AuthService.Create should be invoked
func (mmCreate *mAuthServiceMockCreate) Times(n uint64) *mAuthServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of AuthServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mAuthServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements service.AuthService
func (mmCreate *AuthServiceMock) Create(ctx context.Context, info *model.UserInfo, password string, passwordConfirm string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, info, password, passwordConfirm)
	}

	mm_params := AuthServiceMockCreateParams{ctx, info, password, passwordConfirm}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockCreateParams{ctx, info, password, passwordConfirm}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("AuthServiceMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreate.t.Errorf("AuthServiceMock.Create got unexpected parameter info, want: %#v, got: %#v%s\n", *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmCreate.t.Errorf("AuthServiceMock.Create got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

			if mm_want_ptrs.passwordConfirm != nil && !minimock.Equal(*mm_want_ptrs.passwordConfirm, mm_got.passwordConfirm) {
				mmCreate.t.Errorf("AuthServiceMock.Create got unexpected parameter passwordConfirm, want: %#v, got: %#v%s\n", *mm_want_ptrs.passwordConfirm, mm_got.passwordConfirm, minimock.Diff(*mm_want_ptrs.passwordConfirm, mm_got.passwordConfirm))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("AuthServiceMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the AuthServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, info, password, passwordConfirm)
	}
	mmCreate.t.Fatalf("Unexpected call to AuthServiceMock.Create. %v %v %v %v", ctx, info, password, passwordConfirm)
	return
}

// CreateAfterCounter returns a count of finished AuthServiceMock.Create invocations
func (mmCreate *AuthServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of AuthServiceMock.Create invocations
func (mmCreate *AuthServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mAuthServiceMockCreate) Calls() []*AuthServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*AuthServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Create")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mAuthServiceMockDelete struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockDeleteExpectation
	expectations       []*AuthServiceMockDeleteExpectation

	callArgs []*AuthServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockDeleteExpectation specifies expectation struct of the AuthService.Delete
type AuthServiceMockDeleteExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockDeleteParams
	paramPtrs *AuthServiceMockDeleteParamPtrs
	results   *AuthServiceMockDeleteResults
	Counter   uint64
}

// AuthServiceMockDeleteParams contains parameters of the AuthService.Delete
type AuthServiceMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// AuthServiceMockDeleteParamPtrs contains pointers to parameters of the AuthService.Delete
type AuthServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthServiceMockDeleteResults contains results of the AuthService.Delete
type AuthServiceMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mAuthServiceMockDelete) Optional() *mAuthServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for AuthService.Delete
func (mmDelete *mAuthServiceMockDelete) Expect(ctx context.Context, id int64) *mAuthServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &AuthServiceMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Delete
func (mmDelete *mAuthServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &AuthServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for AuthService.Delete
func (mmDelete *mAuthServiceMockDelete) ExpectIdParam2(id int64) *mAuthServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &AuthServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Delete
func (mmDelete *mAuthServiceMockDelete) Inspect(f func(ctx context.Context, id int64)) *mAuthServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by AuthService.Delete
func (mmDelete *mAuthServiceMockDelete) Return(err error) *AuthServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &AuthServiceMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the AuthService.Delete method
func (mmDelete *mAuthServiceMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *AuthServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the AuthService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the AuthService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the AuthService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mAuthServiceMockDelete) When(ctx context.Context, id int64) *AuthServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthServiceMock.Delete mock is already set by Set")
	}

	expectation := &AuthServiceMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &AuthServiceMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Delete return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockDeleteExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times AuthService.Delete should be invoked
func (mmDelete *mAuthServiceMockDelete) Times(n uint64) *mAuthServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of AuthServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mAuthServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements service.AuthService
func (mmDelete *AuthServiceMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := AuthServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("AuthServiceMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("AuthServiceMock.Delete got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("AuthServiceMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the AuthServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to AuthServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished AuthServiceMock.Delete invocations
func (mmDelete *AuthServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of AuthServiceMock.Delete invocations
func (mmDelete *AuthServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mAuthServiceMockDelete) Calls() []*AuthServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*AuthServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Delete")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mAuthServiceMockGet struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetExpectation
	expectations       []*AuthServiceMockGetExpectation

	callArgs []*AuthServiceMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockGetExpectation specifies expectation struct of the AuthService.Get
type AuthServiceMockGetExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockGetParams
	paramPtrs *AuthServiceMockGetParamPtrs
	results   *AuthServiceMockGetResults
	Counter   uint64
}

// AuthServiceMockGetParams contains parameters of the AuthService.Get
type AuthServiceMockGetParams struct {
	ctx context.Context
	id  int64
}

// AuthServiceMockGetParamPtrs contains pointers to parameters of the AuthService.Get
type AuthServiceMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthServiceMockGetResults contains results of the AuthService.Get
type AuthServiceMockGetResults struct {
	up1 *model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mAuthServiceMockGet) Optional() *mAuthServiceMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for AuthService.Get
func (mmGet *mAuthServiceMockGet) Expect(ctx context.Context, id int64) *mAuthServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &AuthServiceMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Get
func (mmGet *mAuthServiceMockGet) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AuthServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectIdParam2 sets up expected param id for AuthService.Get
func (mmGet *mAuthServiceMockGet) ExpectIdParam2(id int64) *mAuthServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AuthServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Get
func (mmGet *mAuthServiceMockGet) Inspect(f func(ctx context.Context, id int64)) *mAuthServiceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by AuthService.Get
func (mmGet *mAuthServiceMockGet) Return(up1 *model.User, err error) *AuthServiceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthServiceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &AuthServiceMockGetResults{up1, err}
	return mmGet.mock
}

// Set uses given function f to mock the AuthService.Get method
func (mmGet *mAuthServiceMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *AuthServiceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the AuthService.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the AuthService.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the AuthService.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAuthServiceMockGet) When(ctx context.Context, id int64) *AuthServiceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthServiceMock.Get mock is already set by Set")
	}

	expectation := &AuthServiceMockGetExpectation{
		mock:   mmGet.mock,
		params: &AuthServiceMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Get return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetExpectation) Then(up1 *model.User, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times AuthService.Get should be invoked
func (mmGet *mAuthServiceMockGet) Times(n uint64) *mAuthServiceMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of AuthServiceMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mAuthServiceMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements service.AuthService
func (mmGet *AuthServiceMock) Get(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := AuthServiceMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("AuthServiceMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("AuthServiceMock.Get got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("AuthServiceMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the AuthServiceMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to AuthServiceMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished AuthServiceMock.Get invocations
func (mmGet *AuthServiceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of AuthServiceMock.Get invocations
func (mmGet *AuthServiceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAuthServiceMockGet) Calls() []*AuthServiceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Get")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

type mAuthServiceMockGetAccessToken struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetAccessTokenExpectation
	expectations       []*AuthServiceMockGetAccessTokenExpectation

	callArgs []*AuthServiceMockGetAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockGetAccessTokenExpectation specifies expectation struct of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockGetAccessTokenParams
	paramPtrs *AuthServiceMockGetAccessTokenParamPtrs
	results   *AuthServiceMockGetAccessTokenResults
	Counter   uint64
}

// AuthServiceMockGetAccessTokenParams contains parameters of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// AuthServiceMockGetAccessTokenParamPtrs contains pointers to parameters of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// AuthServiceMockGetAccessTokenResults contains results of the AuthService.GetAccessToken
type AuthServiceMockGetAccessTokenResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Optional() *mAuthServiceMockGetAccessToken {
	mmGetAccessToken.optional = true
	return mmGetAccessToken
}

// Expect sets up expected params for AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Expect(ctx context.Context, refreshToken string) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by ExpectParams functions")
	}

	mmGetAccessToken.defaultExpectation.params = &AuthServiceMockGetAccessTokenParams{ctx, refreshToken}
	for _, e := range mmGetAccessToken.expectations {
		if minimock.Equal(e.params, mmGetAccessToken.defaultExpectation.params) {
			mmGetAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessToken.defaultExpectation.params)
		}
	}

	return mmGetAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &AuthServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAccessToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) ExpectRefreshTokenParam2(refreshToken string) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &AuthServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken

	return mmGetAccessToken
}

// Inspect accepts an inspector function that has same arguments as the AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mAuthServiceMockGetAccessToken {
	if mmGetAccessToken.mock.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.GetAccessToken")
	}

	mmGetAccessToken.mock.inspectFuncGetAccessToken = f

	return mmGetAccessToken
}

// Return sets up results that will be returned by AuthService.GetAccessToken
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Return(s1 string, err error) *AuthServiceMock {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &AuthServiceMockGetAccessTokenExpectation{mock: mmGetAccessToken.mock}
	}
	mmGetAccessToken.defaultExpectation.results = &AuthServiceMockGetAccessTokenResults{s1, err}
	return mmGetAccessToken.mock
}

// Set uses given function f to mock the AuthService.GetAccessToken method
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *AuthServiceMock {
	if mmGetAccessToken.defaultExpectation != nil {
		mmGetAccessToken.mock.t.Fatalf("Default expectation is already set for the AuthService.GetAccessToken method")
	}

	if len(mmGetAccessToken.expectations) > 0 {
		mmGetAccessToken.mock.t.Fatalf("Some expectations are already set for the AuthService.GetAccessToken method")
	}

	mmGetAccessToken.mock.funcGetAccessToken = f
	return mmGetAccessToken.mock
}

// When sets expectation for the AuthService.GetAccessToken which will trigger the result defined by the following
// Then helper
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) When(ctx context.Context, refreshToken string) *AuthServiceMockGetAccessTokenExpectation {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("AuthServiceMock.GetAccessToken mock is already set by Set")
	}

	expectation := &AuthServiceMockGetAccessTokenExpectation{
		mock:   mmGetAccessToken.mock,
		params: &AuthServiceMockGetAccessTokenParams{ctx, refreshToken},
	}
	mmGetAccessToken.expectations = append(mmGetAccessToken.expectations, expectation)
	return expectation
}

// Then sets up AuthService.GetAccessToken return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetAccessTokenExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetAccessTokenResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.GetAccessToken should be invoked
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Times(n uint64) *mAuthServiceMockGetAccessToken {
	if n == 0 {
		mmGetAccessToken.mock.t.Fatalf("Times of AuthServiceMock.GetAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccessToken.expectedInvocations, n)
	return mmGetAccessToken
}

func (mmGetAccessToken *mAuthServiceMockGetAccessToken) invocationsDone() bool {
	if len(mmGetAccessToken.expectations) == 0 && mmGetAccessToken.defaultExpectation == nil && mmGetAccessToken.mock.funcGetAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.mock.afterGetAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccessToken implements service.AuthService
func (mmGetAccessToken *AuthServiceMock) GetAccessToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetAccessToken.beforeGetAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessToken.afterGetAccessTokenCounter, 1)

	if mmGetAccessToken.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.inspectFuncGetAccessToken(ctx, refreshToken)
	}

	mm_params := AuthServiceMockGetAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmGetAccessToken.GetAccessTokenMock.mutex.Lock()
	mmGetAccessToken.GetAccessTokenMock.callArgs = append(mmGetAccessToken.GetAccessTokenMock.callArgs, &mm_params)
	mmGetAccessToken.GetAccessTokenMock.mutex.Unlock()

	for _, e := range mmGetAccessToken.GetAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetAccessToken.GetAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessToken.GetAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetAccessTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccessToken.t.Errorf("AuthServiceMock.GetAccessToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmGetAccessToken.t.Errorf("AuthServiceMock.GetAccessToken got unexpected parameter refreshToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessToken.t.Errorf("AuthServiceMock.GetAccessToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessToken.t.Fatal("No results are set for the AuthServiceMock.GetAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetAccessToken.funcGetAccessToken != nil {
		return mmGetAccessToken.funcGetAccessToken(ctx, refreshToken)
	}
	mmGetAccessToken.t.Fatalf("Unexpected call to AuthServiceMock.GetAccessToken. %v %v", ctx, refreshToken)
	return
}

// GetAccessTokenAfterCounter returns a count of finished AuthServiceMock.GetAccessToken invocations
func (mmGetAccessToken *AuthServiceMock) GetAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.afterGetAccessTokenCounter)
}

// GetAccessTokenBeforeCounter returns a count of AuthServiceMock.GetAccessToken invocations
func (mmGetAccessToken *AuthServiceMock) GetAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.beforeGetAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.GetAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessToken *mAuthServiceMockGetAccessToken) Calls() []*AuthServiceMockGetAccessTokenParams {
	mmGetAccessToken.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetAccessTokenParams, len(mmGetAccessToken.callArgs))
	copy(argCopy, mmGetAccessToken.callArgs)

	mmGetAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenDone returns true if the count of the GetAccessToken invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetAccessTokenDone() bool {
	if m.GetAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessTokenMock.invocationsDone()
}

// MinimockGetAccessTokenInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetAccessTokenInspect() {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.GetAccessToken with params: %#v", *e.params)
		}
	}

	afterGetAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && afterGetAccessTokenCounter < 1 {
		if m.GetAccessTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.GetAccessToken")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.GetAccessToken with params: %#v", *m.GetAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && afterGetAccessTokenCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.GetAccessToken")
	}

	if !m.GetAccessTokenMock.invocationsDone() && afterGetAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.GetAccessToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessTokenMock.expectedInvocations), afterGetAccessTokenCounter)
	}
}

type mAuthServiceMockGetList struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetListExpectation
	expectations       []*AuthServiceMockGetListExpectation

	callArgs []*AuthServiceMockGetListParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockGetListExpectation specifies expectation struct of the AuthService.GetList
type AuthServiceMockGetListExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockGetListParams
	paramPtrs *AuthServiceMockGetListParamPtrs
	results   *AuthServiceMockGetListResults
	Counter   uint64
}

// AuthServiceMockGetListParams contains parameters of the AuthService.GetList
type AuthServiceMockGetListParams struct {
	ctx   context.Context
	limit pagination.Limit
}

// AuthServiceMockGetListParamPtrs contains pointers to parameters of the AuthService.GetList
type AuthServiceMockGetListParamPtrs struct {
	ctx   *context.Context
	limit *pagination.Limit
}

// AuthServiceMockGetListResults contains results of the AuthService.GetList
type AuthServiceMockGetListResults struct {
	ua1 []model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetList *mAuthServiceMockGetList) Optional() *mAuthServiceMockGetList {
	mmGetList.optional = true
	return mmGetList
}

// Expect sets up expected params for AuthService.GetList
func (mmGetList *mAuthServiceMockGetList) Expect(ctx context.Context, limit pagination.Limit) *mAuthServiceMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &AuthServiceMockGetListExpectation{}
	}

	if mmGetList.defaultExpectation.paramPtrs != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by ExpectParams functions")
	}

	mmGetList.defaultExpectation.params = &AuthServiceMockGetListParams{ctx, limit}
	for _, e := range mmGetList.expectations {
		if minimock.Equal(e.params, mmGetList.defaultExpectation.params) {
			mmGetList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetList.defaultExpectation.params)
		}
	}

	return mmGetList
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.GetList
func (mmGetList *mAuthServiceMockGetList) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &AuthServiceMockGetListExpectation{}
	}

	if mmGetList.defaultExpectation.params != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Expect")
	}

	if mmGetList.defaultExpectation.paramPtrs == nil {
		mmGetList.defaultExpectation.paramPtrs = &AuthServiceMockGetListParamPtrs{}
	}
	mmGetList.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetList
}

// ExpectLimitParam2 sets up expected param limit for AuthService.GetList
func (mmGetList *mAuthServiceMockGetList) ExpectLimitParam2(limit pagination.Limit) *mAuthServiceMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &AuthServiceMockGetListExpectation{}
	}

	if mmGetList.defaultExpectation.params != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Expect")
	}

	if mmGetList.defaultExpectation.paramPtrs == nil {
		mmGetList.defaultExpectation.paramPtrs = &AuthServiceMockGetListParamPtrs{}
	}
	mmGetList.defaultExpectation.paramPtrs.limit = &limit

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the AuthService.GetList
func (mmGetList *mAuthServiceMockGetList) Inspect(f func(ctx context.Context, limit pagination.Limit)) *mAuthServiceMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by AuthService.GetList
func (mmGetList *mAuthServiceMockGetList) Return(ua1 []model.User, err error) *AuthServiceMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &AuthServiceMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &AuthServiceMockGetListResults{ua1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the AuthService.GetList method
func (mmGetList *mAuthServiceMockGetList) Set(f func(ctx context.Context, limit pagination.Limit) (ua1 []model.User, err error)) *AuthServiceMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the AuthService.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the AuthService.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// When sets expectation for the AuthService.GetList which will trigger the result defined by the following
// Then helper
func (mmGetList *mAuthServiceMockGetList) When(ctx context.Context, limit pagination.Limit) *AuthServiceMockGetListExpectation {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("AuthServiceMock.GetList mock is already set by Set")
	}

	expectation := &AuthServiceMockGetListExpectation{
		mock:   mmGetList.mock,
		params: &AuthServiceMockGetListParams{ctx, limit},
	}
	mmGetList.expectations = append(mmGetList.expectations, expectation)
	return expectation
}

// Then sets up AuthService.GetList return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetListExpectation) Then(ua1 []model.User, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetListResults{ua1, err}
	return e.mock
}

// Times sets number of times AuthService.GetList should be invoked
func (mmGetList *mAuthServiceMockGetList) Times(n uint64) *mAuthServiceMockGetList {
	if n == 0 {
		mmGetList.mock.t.Fatalf("Times of AuthServiceMock.GetList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetList.expectedInvocations, n)
	return mmGetList
}

func (mmGetList *mAuthServiceMockGetList) invocationsDone() bool {
	if len(mmGetList.expectations) == 0 && mmGetList.defaultExpectation == nil && mmGetList.mock.funcGetList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetList.mock.afterGetListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetList implements service.AuthService
func (mmGetList *AuthServiceMock) GetList(ctx context.Context, limit pagination.Limit) (ua1 []model.User, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList(ctx, limit)
	}

	mm_params := AuthServiceMockGetListParams{ctx, limit}

	// Record call args
	mmGetList.GetListMock.mutex.Lock()
	mmGetList.GetListMock.callArgs = append(mmGetList.GetListMock.callArgs, &mm_params)
	mmGetList.GetListMock.mutex.Unlock()

	for _, e := range mmGetList.GetListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetList.GetListMock.defaultExpectation.params
		mm_want_ptrs := mmGetList.GetListMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetListParams{ctx, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetList.t.Errorf("AuthServiceMock.GetList got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetList.t.Errorf("AuthServiceMock.GetList got unexpected parameter limit, want: %#v, got: %#v%s\n", *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetList.t.Errorf("AuthServiceMock.GetList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the AuthServiceMock.GetList")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList(ctx, limit)
	}
	mmGetList.t.Fatalf("Unexpected call to AuthServiceMock.GetList. %v %v", ctx, limit)
	return
}

// GetListAfterCounter returns a count of finished AuthServiceMock.GetList invocations
func (mmGetList *AuthServiceMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of AuthServiceMock.GetList invocations
func (mmGetList *AuthServiceMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.GetList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetList *mAuthServiceMockGetList) Calls() []*AuthServiceMockGetListParams {
	mmGetList.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetListParams, len(mmGetList.callArgs))
	copy(argCopy, mmGetList.callArgs)

	mmGetList.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetListDone() bool {
	if m.GetListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListMock.invocationsDone()
}

// MinimockGetListInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.GetList with params: %#v", *e.params)
		}
	}

	afterGetListCounter := mm_atomic.LoadUint64(&m.afterGetListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && afterGetListCounter < 1 {
		if m.GetListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.GetList")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.GetList with params: %#v", *m.GetListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && afterGetListCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.GetList")
	}

	if !m.GetListMock.invocationsDone() && afterGetListCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.GetList but found %d calls",
			mm_atomic.LoadUint64(&m.GetListMock.expectedInvocations), afterGetListCounter)
	}
}

type mAuthServiceMockGetRefreshToken struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockGetRefreshTokenExpectation
	expectations       []*AuthServiceMockGetRefreshTokenExpectation

	callArgs []*AuthServiceMockGetRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockGetRefreshTokenExpectation specifies expectation struct of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockGetRefreshTokenParams
	paramPtrs *AuthServiceMockGetRefreshTokenParamPtrs
	results   *AuthServiceMockGetRefreshTokenResults
	Counter   uint64
}

// AuthServiceMockGetRefreshTokenParams contains parameters of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// AuthServiceMockGetRefreshTokenParamPtrs contains pointers to parameters of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// AuthServiceMockGetRefreshTokenResults contains results of the AuthService.GetRefreshToken
type AuthServiceMockGetRefreshTokenResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Optional() *mAuthServiceMockGetRefreshToken {
	mmGetRefreshToken.optional = true
	return mmGetRefreshToken
}

// Expect sets up expected params for AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Expect(ctx context.Context, refreshToken string) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by ExpectParams functions")
	}

	mmGetRefreshToken.defaultExpectation.params = &AuthServiceMockGetRefreshTokenParams{ctx, refreshToken}
	for _, e := range mmGetRefreshToken.expectations {
		if minimock.Equal(e.params, mmGetRefreshToken.defaultExpectation.params) {
			mmGetRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshToken.defaultExpectation.params)
		}
	}

	return mmGetRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &AuthServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRefreshToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) ExpectRefreshTokenParam2(refreshToken string) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &AuthServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken

	return mmGetRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Inspect(f func(ctx context.Context, refreshToken string)) *mAuthServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.GetRefreshToken")
	}

	mmGetRefreshToken.mock.inspectFuncGetRefreshToken = f

	return mmGetRefreshToken
}

// Return sets up results that will be returned by AuthService.GetRefreshToken
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Return(s1 string, err error) *AuthServiceMock {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &AuthServiceMockGetRefreshTokenExpectation{mock: mmGetRefreshToken.mock}
	}
	mmGetRefreshToken.defaultExpectation.results = &AuthServiceMockGetRefreshTokenResults{s1, err}
	return mmGetRefreshToken.mock
}

// Set uses given function f to mock the AuthService.GetRefreshToken method
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *AuthServiceMock {
	if mmGetRefreshToken.defaultExpectation != nil {
		mmGetRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthService.GetRefreshToken method")
	}

	if len(mmGetRefreshToken.expectations) > 0 {
		mmGetRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthService.GetRefreshToken method")
	}

	mmGetRefreshToken.mock.funcGetRefreshToken = f
	return mmGetRefreshToken.mock
}

// When sets expectation for the AuthService.GetRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) When(ctx context.Context, refreshToken string) *AuthServiceMockGetRefreshTokenExpectation {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("AuthServiceMock.GetRefreshToken mock is already set by Set")
	}

	expectation := &AuthServiceMockGetRefreshTokenExpectation{
		mock:   mmGetRefreshToken.mock,
		params: &AuthServiceMockGetRefreshTokenParams{ctx, refreshToken},
	}
	mmGetRefreshToken.expectations = append(mmGetRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up AuthService.GetRefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockGetRefreshTokenExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockGetRefreshTokenResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.GetRefreshToken should be invoked
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Times(n uint64) *mAuthServiceMockGetRefreshToken {
	if n == 0 {
		mmGetRefreshToken.mock.t.Fatalf("Times of AuthServiceMock.GetRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefreshToken.expectedInvocations, n)
	return mmGetRefreshToken
}

func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) invocationsDone() bool {
	if len(mmGetRefreshToken.expectations) == 0 && mmGetRefreshToken.defaultExpectation == nil && mmGetRefreshToken.mock.funcGetRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.mock.afterGetRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefreshToken implements service.AuthService
func (mmGetRefreshToken *AuthServiceMock) GetRefreshToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter, 1)

	if mmGetRefreshToken.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.inspectFuncGetRefreshToken(ctx, refreshToken)
	}

	mm_params := AuthServiceMockGetRefreshTokenParams{ctx, refreshToken}

	// Record call args
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Lock()
	mmGetRefreshToken.GetRefreshTokenMock.callArgs = append(mmGetRefreshToken.GetRefreshTokenMock.callArgs, &mm_params)
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGetRefreshToken.GetRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockGetRefreshTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefreshToken.t.Errorf("AuthServiceMock.GetRefreshToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmGetRefreshToken.t.Errorf("AuthServiceMock.GetRefreshToken got unexpected parameter refreshToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshToken.t.Errorf("AuthServiceMock.GetRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshToken.t.Fatal("No results are set for the AuthServiceMock.GetRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetRefreshToken.funcGetRefreshToken != nil {
		return mmGetRefreshToken.funcGetRefreshToken(ctx, refreshToken)
	}
	mmGetRefreshToken.t.Fatalf("Unexpected call to AuthServiceMock.GetRefreshToken. %v %v", ctx, refreshToken)
	return
}

// GetRefreshTokenAfterCounter returns a count of finished AuthServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *AuthServiceMock) GetRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter)
}

// GetRefreshTokenBeforeCounter returns a count of AuthServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *AuthServiceMock) GetRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.GetRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshToken *mAuthServiceMockGetRefreshToken) Calls() []*AuthServiceMockGetRefreshTokenParams {
	mmGetRefreshToken.mutex.RLock()

	argCopy := make([]*AuthServiceMockGetRefreshTokenParams, len(mmGetRefreshToken.callArgs))
	copy(argCopy, mmGetRefreshToken.callArgs)

	mmGetRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenDone returns true if the count of the GetRefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockGetRefreshTokenDone() bool {
	if m.GetRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefreshTokenMock.invocationsDone()
}

// MinimockGetRefreshTokenInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockGetRefreshTokenInspect() {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.GetRefreshToken with params: %#v", *e.params)
		}
	}

	afterGetRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && afterGetRefreshTokenCounter < 1 {
		if m.GetRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.GetRefreshToken")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.GetRefreshToken with params: %#v", *m.GetRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && afterGetRefreshTokenCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.GetRefreshToken")
	}

	if !m.GetRefreshTokenMock.invocationsDone() && afterGetRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.GetRefreshToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefreshTokenMock.expectedInvocations), afterGetRefreshTokenCounter)
	}
}

type mAuthServiceMockLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginExpectation
	expectations       []*AuthServiceMockLoginExpectation

	callArgs []*AuthServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockLoginExpectation specifies expectation struct of the AuthService.Login
type AuthServiceMockLoginExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockLoginParams
	paramPtrs *AuthServiceMockLoginParamPtrs
	results   *AuthServiceMockLoginResults
	Counter   uint64
}

// AuthServiceMockLoginParams contains parameters of the AuthService.Login
type AuthServiceMockLoginParams struct {
	ctx      context.Context
	email    string
	password string
}

// AuthServiceMockLoginParamPtrs contains pointers to parameters of the AuthService.Login
type AuthServiceMockLoginParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
}

// AuthServiceMockLoginResults contains results of the AuthService.Login
type AuthServiceMockLoginResults struct {
	tp1 *model.TokenPair
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mAuthServiceMockLogin) Optional() *mAuthServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Expect(ctx context.Context, email string, password string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &AuthServiceMockLoginParams{ctx, email, password}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLogin
}

// ExpectEmailParam2 sets up expected param email for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectEmailParam2(email string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.email = &email

	return mmLogin
}

// ExpectPasswordParam3 sets up expected param password for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectPasswordParam3(password string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.password = &password

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Inspect(f func(ctx context.Context, email string, password string)) *mAuthServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Return(tp1 *model.TokenPair, err error) *AuthServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &AuthServiceMockLoginResults{tp1, err}
	return mmLogin.mock
}

// Set uses given function f to mock the AuthService.Login method
func (mmLogin *mAuthServiceMockLogin) Set(f func(ctx context.Context, email string, password string) (tp1 *model.TokenPair, err error)) *AuthServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the AuthService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mAuthServiceMockLogin) When(ctx context.Context, email string, password string) *AuthServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &AuthServiceMockLoginParams{ctx, email, password},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Login return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginExpectation) Then(tp1 *model.TokenPair, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginResults{tp1, err}
	return e.mock
}

// Times sets number of times AuthService.Login should be invoked
func (mmLogin *mAuthServiceMockLogin) Times(n uint64) *mAuthServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of AuthServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	return mmLogin
}

func (mmLogin *mAuthServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements service.AuthService
func (mmLogin *AuthServiceMock) Login(ctx context.Context, email string, password string) (tp1 *model.TokenPair, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, email, password)
	}

	mm_params := AuthServiceMockLoginParams{ctx, email, password}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginParams{ctx, email, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter email, want: %#v, got: %#v%s\n", *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter password, want: %#v, got: %#v%s\n", *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the AuthServiceMock.Login")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, email, password)
	}
	mmLogin.t.Fatalf("Unexpected call to AuthServiceMock.Login. %v %v %v", ctx, email, password)
	return
}

// LoginAfterCounter returns a count of finished AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mAuthServiceMockLogin) Calls() []*AuthServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Login with params: %#v", *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Login")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Login")
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Login but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), afterLoginCounter)
	}
}

type mAuthServiceMockUpdate struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockUpdateExpectation
	expectations       []*AuthServiceMockUpdateExpectation

	callArgs []*AuthServiceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthServiceMockUpdateExpectation specifies expectation struct of the AuthService.Update
type AuthServiceMockUpdateExpectation struct {
	mock      *AuthServiceMock
	params    *AuthServiceMockUpdateParams
	paramPtrs *AuthServiceMockUpdateParamPtrs
	results   *AuthServiceMockUpdateResults
	Counter   uint64
}

// AuthServiceMockUpdateParams contains parameters of the AuthService.Update
type AuthServiceMockUpdateParams struct {
	ctx  context.Context
	id   int64
	info *model.UpdateUserInfo
}

// AuthServiceMockUpdateParamPtrs contains pointers to parameters of the AuthService.Update
type AuthServiceMockUpdateParamPtrs struct {
	ctx  *context.Context
	id   *int64
	info **model.UpdateUserInfo
}

// AuthServiceMockUpdateResults contains results of the AuthService.Update
type AuthServiceMockUpdateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mAuthServiceMockUpdate) Optional() *mAuthServiceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for AuthService.Update
func (mmUpdate *mAuthServiceMockUpdate) Expect(ctx context.Context, id int64, info *model.UpdateUserInfo) *mAuthServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &AuthServiceMockUpdateParams{ctx, id, info}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Update
func (mmUpdate *mAuthServiceMockUpdate) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &AuthServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for AuthService.Update
func (mmUpdate *mAuthServiceMockUpdate) ExpectIdParam2(id int64) *mAuthServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &AuthServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id

	return mmUpdate
}

// ExpectInfoParam3 sets up expected param info for AuthService.Update
func (mmUpdate *mAuthServiceMockUpdate) ExpectInfoParam3(info *model.UpdateUserInfo) *mAuthServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &AuthServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.info = &info

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Update
func (mmUpdate *mAuthServiceMockUpdate) Inspect(f func(ctx context.Context, id int64, info *model.UpdateUserInfo)) *mAuthServiceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by AuthService.Update
func (mmUpdate *mAuthServiceMockUpdate) Return(err error) *AuthServiceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthServiceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &AuthServiceMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the AuthService.Update method
func (mmUpdate *mAuthServiceMockUpdate) Set(f func(ctx context.Context, id int64, info *model.UpdateUserInfo) (err error)) *AuthServiceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the AuthService.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the AuthService.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the AuthService.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mAuthServiceMockUpdate) When(ctx context.Context, id int64, info *model.UpdateUserInfo) *AuthServiceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthServiceMock.Update mock is already set by Set")
	}

	expectation := &AuthServiceMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &AuthServiceMockUpdateParams{ctx, id, info},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Update return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockUpdateExpectation) Then(err error) *AuthServiceMock {
	e.results = &AuthServiceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times AuthService.Update should be invoked
func (mmUpdate *mAuthServiceMockUpdate) Times(n uint64) *mAuthServiceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of AuthServiceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	return mmUpdate
}

func (mmUpdate *mAuthServiceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements service.AuthService
func (mmUpdate *AuthServiceMock) Update(ctx context.Context, id int64, info *model.UpdateUserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, info)
	}

	mm_params := AuthServiceMockUpdateParams{ctx, id, info}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockUpdateParams{ctx, id, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("AuthServiceMock.Update got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("AuthServiceMock.Update got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdate.t.Errorf("AuthServiceMock.Update got unexpected parameter info, want: %#v, got: %#v%s\n", *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("AuthServiceMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the AuthServiceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, info)
	}
	mmUpdate.t.Fatalf("Unexpected call to AuthServiceMock.Update. %v %v %v", ctx, id, info)
	return
}

// UpdateAfterCounter returns a count of finished AuthServiceMock.Update invocations
func (mmUpdate *AuthServiceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of AuthServiceMock.Update invocations
func (mmUpdate *AuthServiceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mAuthServiceMockUpdate) Calls() []*AuthServiceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*AuthServiceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Update with params: %#v", *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthServiceMock.Update")
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Error("Expected call to AuthServiceMock.Update")
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Update but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetAccessTokenInspect()

			m.MinimockGetListInspect()

			m.MinimockGetRefreshTokenInspect()

			m.MinimockLoginInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetAccessTokenDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetRefreshTokenDone() &&
		m.MinimockLoginDone() &&
		m.MinimockUpdateDone()
}
