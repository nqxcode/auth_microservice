// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/nqxcode/auth_microservice/internal/config.AuthConfig -o auth_config_minimock.go -n AuthConfigMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AuthConfigMock implements config.AuthConfig
type AuthConfigMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAccessTokenExpiration          func() (d1 time.Duration)
	inspectFuncAccessTokenExpiration   func()
	afterAccessTokenExpirationCounter  uint64
	beforeAccessTokenExpirationCounter uint64
	AccessTokenExpirationMock          mAuthConfigMockAccessTokenExpiration

	funcAccessTokenSecretKey          func() (s1 string)
	inspectFuncAccessTokenSecretKey   func()
	afterAccessTokenSecretKeyCounter  uint64
	beforeAccessTokenSecretKeyCounter uint64
	AccessTokenSecretKeyMock          mAuthConfigMockAccessTokenSecretKey

	funcRefreshTokenExpiration          func() (d1 time.Duration)
	inspectFuncRefreshTokenExpiration   func()
	afterRefreshTokenExpirationCounter  uint64
	beforeRefreshTokenExpirationCounter uint64
	RefreshTokenExpirationMock          mAuthConfigMockRefreshTokenExpiration

	funcRefreshTokenSecretKey          func() (s1 string)
	inspectFuncRefreshTokenSecretKey   func()
	afterRefreshTokenSecretKeyCounter  uint64
	beforeRefreshTokenSecretKeyCounter uint64
	RefreshTokenSecretKeyMock          mAuthConfigMockRefreshTokenSecretKey
}

// NewAuthConfigMock returns a mock for config.AuthConfig
func NewAuthConfigMock(t minimock.Tester) *AuthConfigMock {
	m := &AuthConfigMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccessTokenExpirationMock = mAuthConfigMockAccessTokenExpiration{mock: m}

	m.AccessTokenSecretKeyMock = mAuthConfigMockAccessTokenSecretKey{mock: m}

	m.RefreshTokenExpirationMock = mAuthConfigMockRefreshTokenExpiration{mock: m}

	m.RefreshTokenSecretKeyMock = mAuthConfigMockRefreshTokenSecretKey{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthConfigMockAccessTokenExpiration struct {
	optional           bool
	mock               *AuthConfigMock
	defaultExpectation *AuthConfigMockAccessTokenExpirationExpectation
	expectations       []*AuthConfigMockAccessTokenExpirationExpectation

	expectedInvocations uint64
}

// AuthConfigMockAccessTokenExpirationExpectation specifies expectation struct of the AuthConfig.AccessTokenExpiration
type AuthConfigMockAccessTokenExpirationExpectation struct {
	mock *AuthConfigMock

	results *AuthConfigMockAccessTokenExpirationResults
	Counter uint64
}

// AuthConfigMockAccessTokenExpirationResults contains results of the AuthConfig.AccessTokenExpiration
type AuthConfigMockAccessTokenExpirationResults struct {
	d1 time.Duration
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) Optional() *mAuthConfigMockAccessTokenExpiration {
	mmAccessTokenExpiration.optional = true
	return mmAccessTokenExpiration
}

// Expect sets up expected params for AuthConfig.AccessTokenExpiration
func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) Expect() *mAuthConfigMockAccessTokenExpiration {
	if mmAccessTokenExpiration.mock.funcAccessTokenExpiration != nil {
		mmAccessTokenExpiration.mock.t.Fatalf("AuthConfigMock.AccessTokenExpiration mock is already set by Set")
	}

	if mmAccessTokenExpiration.defaultExpectation == nil {
		mmAccessTokenExpiration.defaultExpectation = &AuthConfigMockAccessTokenExpirationExpectation{}
	}

	return mmAccessTokenExpiration
}

// Inspect accepts an inspector function that has same arguments as the AuthConfig.AccessTokenExpiration
func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) Inspect(f func()) *mAuthConfigMockAccessTokenExpiration {
	if mmAccessTokenExpiration.mock.inspectFuncAccessTokenExpiration != nil {
		mmAccessTokenExpiration.mock.t.Fatalf("Inspect function is already set for AuthConfigMock.AccessTokenExpiration")
	}

	mmAccessTokenExpiration.mock.inspectFuncAccessTokenExpiration = f

	return mmAccessTokenExpiration
}

// Return sets up results that will be returned by AuthConfig.AccessTokenExpiration
func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) Return(d1 time.Duration) *AuthConfigMock {
	if mmAccessTokenExpiration.mock.funcAccessTokenExpiration != nil {
		mmAccessTokenExpiration.mock.t.Fatalf("AuthConfigMock.AccessTokenExpiration mock is already set by Set")
	}

	if mmAccessTokenExpiration.defaultExpectation == nil {
		mmAccessTokenExpiration.defaultExpectation = &AuthConfigMockAccessTokenExpirationExpectation{mock: mmAccessTokenExpiration.mock}
	}
	mmAccessTokenExpiration.defaultExpectation.results = &AuthConfigMockAccessTokenExpirationResults{d1}
	return mmAccessTokenExpiration.mock
}

// Set uses given function f to mock the AuthConfig.AccessTokenExpiration method
func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) Set(f func() (d1 time.Duration)) *AuthConfigMock {
	if mmAccessTokenExpiration.defaultExpectation != nil {
		mmAccessTokenExpiration.mock.t.Fatalf("Default expectation is already set for the AuthConfig.AccessTokenExpiration method")
	}

	if len(mmAccessTokenExpiration.expectations) > 0 {
		mmAccessTokenExpiration.mock.t.Fatalf("Some expectations are already set for the AuthConfig.AccessTokenExpiration method")
	}

	mmAccessTokenExpiration.mock.funcAccessTokenExpiration = f
	return mmAccessTokenExpiration.mock
}

// Times sets number of times AuthConfig.AccessTokenExpiration should be invoked
func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) Times(n uint64) *mAuthConfigMockAccessTokenExpiration {
	if n == 0 {
		mmAccessTokenExpiration.mock.t.Fatalf("Times of AuthConfigMock.AccessTokenExpiration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAccessTokenExpiration.expectedInvocations, n)
	return mmAccessTokenExpiration
}

func (mmAccessTokenExpiration *mAuthConfigMockAccessTokenExpiration) invocationsDone() bool {
	if len(mmAccessTokenExpiration.expectations) == 0 && mmAccessTokenExpiration.defaultExpectation == nil && mmAccessTokenExpiration.mock.funcAccessTokenExpiration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAccessTokenExpiration.mock.afterAccessTokenExpirationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAccessTokenExpiration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AccessTokenExpiration implements config.AuthConfig
func (mmAccessTokenExpiration *AuthConfigMock) AccessTokenExpiration() (d1 time.Duration) {
	mm_atomic.AddUint64(&mmAccessTokenExpiration.beforeAccessTokenExpirationCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessTokenExpiration.afterAccessTokenExpirationCounter, 1)

	if mmAccessTokenExpiration.inspectFuncAccessTokenExpiration != nil {
		mmAccessTokenExpiration.inspectFuncAccessTokenExpiration()
	}

	if mmAccessTokenExpiration.AccessTokenExpirationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessTokenExpiration.AccessTokenExpirationMock.defaultExpectation.Counter, 1)

		mm_results := mmAccessTokenExpiration.AccessTokenExpirationMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessTokenExpiration.t.Fatal("No results are set for the AuthConfigMock.AccessTokenExpiration")
		}
		return (*mm_results).d1
	}
	if mmAccessTokenExpiration.funcAccessTokenExpiration != nil {
		return mmAccessTokenExpiration.funcAccessTokenExpiration()
	}
	mmAccessTokenExpiration.t.Fatalf("Unexpected call to AuthConfigMock.AccessTokenExpiration.")
	return
}

// AccessTokenExpirationAfterCounter returns a count of finished AuthConfigMock.AccessTokenExpiration invocations
func (mmAccessTokenExpiration *AuthConfigMock) AccessTokenExpirationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessTokenExpiration.afterAccessTokenExpirationCounter)
}

// AccessTokenExpirationBeforeCounter returns a count of AuthConfigMock.AccessTokenExpiration invocations
func (mmAccessTokenExpiration *AuthConfigMock) AccessTokenExpirationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessTokenExpiration.beforeAccessTokenExpirationCounter)
}

// MinimockAccessTokenExpirationDone returns true if the count of the AccessTokenExpiration invocations corresponds
// the number of defined expectations
func (m *AuthConfigMock) MinimockAccessTokenExpirationDone() bool {
	if m.AccessTokenExpirationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AccessTokenExpirationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AccessTokenExpirationMock.invocationsDone()
}

// MinimockAccessTokenExpirationInspect logs each unmet expectation
func (m *AuthConfigMock) MinimockAccessTokenExpirationInspect() {
	for _, e := range m.AccessTokenExpirationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AuthConfigMock.AccessTokenExpiration")
		}
	}

	afterAccessTokenExpirationCounter := mm_atomic.LoadUint64(&m.afterAccessTokenExpirationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AccessTokenExpirationMock.defaultExpectation != nil && afterAccessTokenExpirationCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.AccessTokenExpiration")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessTokenExpiration != nil && afterAccessTokenExpirationCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.AccessTokenExpiration")
	}

	if !m.AccessTokenExpirationMock.invocationsDone() && afterAccessTokenExpirationCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthConfigMock.AccessTokenExpiration but found %d calls",
			mm_atomic.LoadUint64(&m.AccessTokenExpirationMock.expectedInvocations), afterAccessTokenExpirationCounter)
	}
}

type mAuthConfigMockAccessTokenSecretKey struct {
	optional           bool
	mock               *AuthConfigMock
	defaultExpectation *AuthConfigMockAccessTokenSecretKeyExpectation
	expectations       []*AuthConfigMockAccessTokenSecretKeyExpectation

	expectedInvocations uint64
}

// AuthConfigMockAccessTokenSecretKeyExpectation specifies expectation struct of the AuthConfig.AccessTokenSecretKey
type AuthConfigMockAccessTokenSecretKeyExpectation struct {
	mock *AuthConfigMock

	results *AuthConfigMockAccessTokenSecretKeyResults
	Counter uint64
}

// AuthConfigMockAccessTokenSecretKeyResults contains results of the AuthConfig.AccessTokenSecretKey
type AuthConfigMockAccessTokenSecretKeyResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) Optional() *mAuthConfigMockAccessTokenSecretKey {
	mmAccessTokenSecretKey.optional = true
	return mmAccessTokenSecretKey
}

// Expect sets up expected params for AuthConfig.AccessTokenSecretKey
func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) Expect() *mAuthConfigMockAccessTokenSecretKey {
	if mmAccessTokenSecretKey.mock.funcAccessTokenSecretKey != nil {
		mmAccessTokenSecretKey.mock.t.Fatalf("AuthConfigMock.AccessTokenSecretKey mock is already set by Set")
	}

	if mmAccessTokenSecretKey.defaultExpectation == nil {
		mmAccessTokenSecretKey.defaultExpectation = &AuthConfigMockAccessTokenSecretKeyExpectation{}
	}

	return mmAccessTokenSecretKey
}

// Inspect accepts an inspector function that has same arguments as the AuthConfig.AccessTokenSecretKey
func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) Inspect(f func()) *mAuthConfigMockAccessTokenSecretKey {
	if mmAccessTokenSecretKey.mock.inspectFuncAccessTokenSecretKey != nil {
		mmAccessTokenSecretKey.mock.t.Fatalf("Inspect function is already set for AuthConfigMock.AccessTokenSecretKey")
	}

	mmAccessTokenSecretKey.mock.inspectFuncAccessTokenSecretKey = f

	return mmAccessTokenSecretKey
}

// Return sets up results that will be returned by AuthConfig.AccessTokenSecretKey
func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) Return(s1 string) *AuthConfigMock {
	if mmAccessTokenSecretKey.mock.funcAccessTokenSecretKey != nil {
		mmAccessTokenSecretKey.mock.t.Fatalf("AuthConfigMock.AccessTokenSecretKey mock is already set by Set")
	}

	if mmAccessTokenSecretKey.defaultExpectation == nil {
		mmAccessTokenSecretKey.defaultExpectation = &AuthConfigMockAccessTokenSecretKeyExpectation{mock: mmAccessTokenSecretKey.mock}
	}
	mmAccessTokenSecretKey.defaultExpectation.results = &AuthConfigMockAccessTokenSecretKeyResults{s1}
	return mmAccessTokenSecretKey.mock
}

// Set uses given function f to mock the AuthConfig.AccessTokenSecretKey method
func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) Set(f func() (s1 string)) *AuthConfigMock {
	if mmAccessTokenSecretKey.defaultExpectation != nil {
		mmAccessTokenSecretKey.mock.t.Fatalf("Default expectation is already set for the AuthConfig.AccessTokenSecretKey method")
	}

	if len(mmAccessTokenSecretKey.expectations) > 0 {
		mmAccessTokenSecretKey.mock.t.Fatalf("Some expectations are already set for the AuthConfig.AccessTokenSecretKey method")
	}

	mmAccessTokenSecretKey.mock.funcAccessTokenSecretKey = f
	return mmAccessTokenSecretKey.mock
}

// Times sets number of times AuthConfig.AccessTokenSecretKey should be invoked
func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) Times(n uint64) *mAuthConfigMockAccessTokenSecretKey {
	if n == 0 {
		mmAccessTokenSecretKey.mock.t.Fatalf("Times of AuthConfigMock.AccessTokenSecretKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAccessTokenSecretKey.expectedInvocations, n)
	return mmAccessTokenSecretKey
}

func (mmAccessTokenSecretKey *mAuthConfigMockAccessTokenSecretKey) invocationsDone() bool {
	if len(mmAccessTokenSecretKey.expectations) == 0 && mmAccessTokenSecretKey.defaultExpectation == nil && mmAccessTokenSecretKey.mock.funcAccessTokenSecretKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAccessTokenSecretKey.mock.afterAccessTokenSecretKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAccessTokenSecretKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AccessTokenSecretKey implements config.AuthConfig
func (mmAccessTokenSecretKey *AuthConfigMock) AccessTokenSecretKey() (s1 string) {
	mm_atomic.AddUint64(&mmAccessTokenSecretKey.beforeAccessTokenSecretKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessTokenSecretKey.afterAccessTokenSecretKeyCounter, 1)

	if mmAccessTokenSecretKey.inspectFuncAccessTokenSecretKey != nil {
		mmAccessTokenSecretKey.inspectFuncAccessTokenSecretKey()
	}

	if mmAccessTokenSecretKey.AccessTokenSecretKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessTokenSecretKey.AccessTokenSecretKeyMock.defaultExpectation.Counter, 1)

		mm_results := mmAccessTokenSecretKey.AccessTokenSecretKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessTokenSecretKey.t.Fatal("No results are set for the AuthConfigMock.AccessTokenSecretKey")
		}
		return (*mm_results).s1
	}
	if mmAccessTokenSecretKey.funcAccessTokenSecretKey != nil {
		return mmAccessTokenSecretKey.funcAccessTokenSecretKey()
	}
	mmAccessTokenSecretKey.t.Fatalf("Unexpected call to AuthConfigMock.AccessTokenSecretKey.")
	return
}

// AccessTokenSecretKeyAfterCounter returns a count of finished AuthConfigMock.AccessTokenSecretKey invocations
func (mmAccessTokenSecretKey *AuthConfigMock) AccessTokenSecretKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessTokenSecretKey.afterAccessTokenSecretKeyCounter)
}

// AccessTokenSecretKeyBeforeCounter returns a count of AuthConfigMock.AccessTokenSecretKey invocations
func (mmAccessTokenSecretKey *AuthConfigMock) AccessTokenSecretKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessTokenSecretKey.beforeAccessTokenSecretKeyCounter)
}

// MinimockAccessTokenSecretKeyDone returns true if the count of the AccessTokenSecretKey invocations corresponds
// the number of defined expectations
func (m *AuthConfigMock) MinimockAccessTokenSecretKeyDone() bool {
	if m.AccessTokenSecretKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AccessTokenSecretKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AccessTokenSecretKeyMock.invocationsDone()
}

// MinimockAccessTokenSecretKeyInspect logs each unmet expectation
func (m *AuthConfigMock) MinimockAccessTokenSecretKeyInspect() {
	for _, e := range m.AccessTokenSecretKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AuthConfigMock.AccessTokenSecretKey")
		}
	}

	afterAccessTokenSecretKeyCounter := mm_atomic.LoadUint64(&m.afterAccessTokenSecretKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AccessTokenSecretKeyMock.defaultExpectation != nil && afterAccessTokenSecretKeyCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.AccessTokenSecretKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessTokenSecretKey != nil && afterAccessTokenSecretKeyCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.AccessTokenSecretKey")
	}

	if !m.AccessTokenSecretKeyMock.invocationsDone() && afterAccessTokenSecretKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthConfigMock.AccessTokenSecretKey but found %d calls",
			mm_atomic.LoadUint64(&m.AccessTokenSecretKeyMock.expectedInvocations), afterAccessTokenSecretKeyCounter)
	}
}

type mAuthConfigMockRefreshTokenExpiration struct {
	optional           bool
	mock               *AuthConfigMock
	defaultExpectation *AuthConfigMockRefreshTokenExpirationExpectation
	expectations       []*AuthConfigMockRefreshTokenExpirationExpectation

	expectedInvocations uint64
}

// AuthConfigMockRefreshTokenExpirationExpectation specifies expectation struct of the AuthConfig.RefreshTokenExpiration
type AuthConfigMockRefreshTokenExpirationExpectation struct {
	mock *AuthConfigMock

	results *AuthConfigMockRefreshTokenExpirationResults
	Counter uint64
}

// AuthConfigMockRefreshTokenExpirationResults contains results of the AuthConfig.RefreshTokenExpiration
type AuthConfigMockRefreshTokenExpirationResults struct {
	d1 time.Duration
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) Optional() *mAuthConfigMockRefreshTokenExpiration {
	mmRefreshTokenExpiration.optional = true
	return mmRefreshTokenExpiration
}

// Expect sets up expected params for AuthConfig.RefreshTokenExpiration
func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) Expect() *mAuthConfigMockRefreshTokenExpiration {
	if mmRefreshTokenExpiration.mock.funcRefreshTokenExpiration != nil {
		mmRefreshTokenExpiration.mock.t.Fatalf("AuthConfigMock.RefreshTokenExpiration mock is already set by Set")
	}

	if mmRefreshTokenExpiration.defaultExpectation == nil {
		mmRefreshTokenExpiration.defaultExpectation = &AuthConfigMockRefreshTokenExpirationExpectation{}
	}

	return mmRefreshTokenExpiration
}

// Inspect accepts an inspector function that has same arguments as the AuthConfig.RefreshTokenExpiration
func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) Inspect(f func()) *mAuthConfigMockRefreshTokenExpiration {
	if mmRefreshTokenExpiration.mock.inspectFuncRefreshTokenExpiration != nil {
		mmRefreshTokenExpiration.mock.t.Fatalf("Inspect function is already set for AuthConfigMock.RefreshTokenExpiration")
	}

	mmRefreshTokenExpiration.mock.inspectFuncRefreshTokenExpiration = f

	return mmRefreshTokenExpiration
}

// Return sets up results that will be returned by AuthConfig.RefreshTokenExpiration
func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) Return(d1 time.Duration) *AuthConfigMock {
	if mmRefreshTokenExpiration.mock.funcRefreshTokenExpiration != nil {
		mmRefreshTokenExpiration.mock.t.Fatalf("AuthConfigMock.RefreshTokenExpiration mock is already set by Set")
	}

	if mmRefreshTokenExpiration.defaultExpectation == nil {
		mmRefreshTokenExpiration.defaultExpectation = &AuthConfigMockRefreshTokenExpirationExpectation{mock: mmRefreshTokenExpiration.mock}
	}
	mmRefreshTokenExpiration.defaultExpectation.results = &AuthConfigMockRefreshTokenExpirationResults{d1}
	return mmRefreshTokenExpiration.mock
}

// Set uses given function f to mock the AuthConfig.RefreshTokenExpiration method
func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) Set(f func() (d1 time.Duration)) *AuthConfigMock {
	if mmRefreshTokenExpiration.defaultExpectation != nil {
		mmRefreshTokenExpiration.mock.t.Fatalf("Default expectation is already set for the AuthConfig.RefreshTokenExpiration method")
	}

	if len(mmRefreshTokenExpiration.expectations) > 0 {
		mmRefreshTokenExpiration.mock.t.Fatalf("Some expectations are already set for the AuthConfig.RefreshTokenExpiration method")
	}

	mmRefreshTokenExpiration.mock.funcRefreshTokenExpiration = f
	return mmRefreshTokenExpiration.mock
}

// Times sets number of times AuthConfig.RefreshTokenExpiration should be invoked
func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) Times(n uint64) *mAuthConfigMockRefreshTokenExpiration {
	if n == 0 {
		mmRefreshTokenExpiration.mock.t.Fatalf("Times of AuthConfigMock.RefreshTokenExpiration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshTokenExpiration.expectedInvocations, n)
	return mmRefreshTokenExpiration
}

func (mmRefreshTokenExpiration *mAuthConfigMockRefreshTokenExpiration) invocationsDone() bool {
	if len(mmRefreshTokenExpiration.expectations) == 0 && mmRefreshTokenExpiration.defaultExpectation == nil && mmRefreshTokenExpiration.mock.funcRefreshTokenExpiration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshTokenExpiration.mock.afterRefreshTokenExpirationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshTokenExpiration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshTokenExpiration implements config.AuthConfig
func (mmRefreshTokenExpiration *AuthConfigMock) RefreshTokenExpiration() (d1 time.Duration) {
	mm_atomic.AddUint64(&mmRefreshTokenExpiration.beforeRefreshTokenExpirationCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshTokenExpiration.afterRefreshTokenExpirationCounter, 1)

	if mmRefreshTokenExpiration.inspectFuncRefreshTokenExpiration != nil {
		mmRefreshTokenExpiration.inspectFuncRefreshTokenExpiration()
	}

	if mmRefreshTokenExpiration.RefreshTokenExpirationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshTokenExpiration.RefreshTokenExpirationMock.defaultExpectation.Counter, 1)

		mm_results := mmRefreshTokenExpiration.RefreshTokenExpirationMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshTokenExpiration.t.Fatal("No results are set for the AuthConfigMock.RefreshTokenExpiration")
		}
		return (*mm_results).d1
	}
	if mmRefreshTokenExpiration.funcRefreshTokenExpiration != nil {
		return mmRefreshTokenExpiration.funcRefreshTokenExpiration()
	}
	mmRefreshTokenExpiration.t.Fatalf("Unexpected call to AuthConfigMock.RefreshTokenExpiration.")
	return
}

// RefreshTokenExpirationAfterCounter returns a count of finished AuthConfigMock.RefreshTokenExpiration invocations
func (mmRefreshTokenExpiration *AuthConfigMock) RefreshTokenExpirationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokenExpiration.afterRefreshTokenExpirationCounter)
}

// RefreshTokenExpirationBeforeCounter returns a count of AuthConfigMock.RefreshTokenExpiration invocations
func (mmRefreshTokenExpiration *AuthConfigMock) RefreshTokenExpirationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokenExpiration.beforeRefreshTokenExpirationCounter)
}

// MinimockRefreshTokenExpirationDone returns true if the count of the RefreshTokenExpiration invocations corresponds
// the number of defined expectations
func (m *AuthConfigMock) MinimockRefreshTokenExpirationDone() bool {
	if m.RefreshTokenExpirationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTokenExpirationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTokenExpirationMock.invocationsDone()
}

// MinimockRefreshTokenExpirationInspect logs each unmet expectation
func (m *AuthConfigMock) MinimockRefreshTokenExpirationInspect() {
	for _, e := range m.RefreshTokenExpirationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AuthConfigMock.RefreshTokenExpiration")
		}
	}

	afterRefreshTokenExpirationCounter := mm_atomic.LoadUint64(&m.afterRefreshTokenExpirationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokenExpirationMock.defaultExpectation != nil && afterRefreshTokenExpirationCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.RefreshTokenExpiration")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshTokenExpiration != nil && afterRefreshTokenExpirationCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.RefreshTokenExpiration")
	}

	if !m.RefreshTokenExpirationMock.invocationsDone() && afterRefreshTokenExpirationCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthConfigMock.RefreshTokenExpiration but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTokenExpirationMock.expectedInvocations), afterRefreshTokenExpirationCounter)
	}
}

type mAuthConfigMockRefreshTokenSecretKey struct {
	optional           bool
	mock               *AuthConfigMock
	defaultExpectation *AuthConfigMockRefreshTokenSecretKeyExpectation
	expectations       []*AuthConfigMockRefreshTokenSecretKeyExpectation

	expectedInvocations uint64
}

// AuthConfigMockRefreshTokenSecretKeyExpectation specifies expectation struct of the AuthConfig.RefreshTokenSecretKey
type AuthConfigMockRefreshTokenSecretKeyExpectation struct {
	mock *AuthConfigMock

	results *AuthConfigMockRefreshTokenSecretKeyResults
	Counter uint64
}

// AuthConfigMockRefreshTokenSecretKeyResults contains results of the AuthConfig.RefreshTokenSecretKey
type AuthConfigMockRefreshTokenSecretKeyResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) Optional() *mAuthConfigMockRefreshTokenSecretKey {
	mmRefreshTokenSecretKey.optional = true
	return mmRefreshTokenSecretKey
}

// Expect sets up expected params for AuthConfig.RefreshTokenSecretKey
func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) Expect() *mAuthConfigMockRefreshTokenSecretKey {
	if mmRefreshTokenSecretKey.mock.funcRefreshTokenSecretKey != nil {
		mmRefreshTokenSecretKey.mock.t.Fatalf("AuthConfigMock.RefreshTokenSecretKey mock is already set by Set")
	}

	if mmRefreshTokenSecretKey.defaultExpectation == nil {
		mmRefreshTokenSecretKey.defaultExpectation = &AuthConfigMockRefreshTokenSecretKeyExpectation{}
	}

	return mmRefreshTokenSecretKey
}

// Inspect accepts an inspector function that has same arguments as the AuthConfig.RefreshTokenSecretKey
func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) Inspect(f func()) *mAuthConfigMockRefreshTokenSecretKey {
	if mmRefreshTokenSecretKey.mock.inspectFuncRefreshTokenSecretKey != nil {
		mmRefreshTokenSecretKey.mock.t.Fatalf("Inspect function is already set for AuthConfigMock.RefreshTokenSecretKey")
	}

	mmRefreshTokenSecretKey.mock.inspectFuncRefreshTokenSecretKey = f

	return mmRefreshTokenSecretKey
}

// Return sets up results that will be returned by AuthConfig.RefreshTokenSecretKey
func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) Return(s1 string) *AuthConfigMock {
	if mmRefreshTokenSecretKey.mock.funcRefreshTokenSecretKey != nil {
		mmRefreshTokenSecretKey.mock.t.Fatalf("AuthConfigMock.RefreshTokenSecretKey mock is already set by Set")
	}

	if mmRefreshTokenSecretKey.defaultExpectation == nil {
		mmRefreshTokenSecretKey.defaultExpectation = &AuthConfigMockRefreshTokenSecretKeyExpectation{mock: mmRefreshTokenSecretKey.mock}
	}
	mmRefreshTokenSecretKey.defaultExpectation.results = &AuthConfigMockRefreshTokenSecretKeyResults{s1}
	return mmRefreshTokenSecretKey.mock
}

// Set uses given function f to mock the AuthConfig.RefreshTokenSecretKey method
func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) Set(f func() (s1 string)) *AuthConfigMock {
	if mmRefreshTokenSecretKey.defaultExpectation != nil {
		mmRefreshTokenSecretKey.mock.t.Fatalf("Default expectation is already set for the AuthConfig.RefreshTokenSecretKey method")
	}

	if len(mmRefreshTokenSecretKey.expectations) > 0 {
		mmRefreshTokenSecretKey.mock.t.Fatalf("Some expectations are already set for the AuthConfig.RefreshTokenSecretKey method")
	}

	mmRefreshTokenSecretKey.mock.funcRefreshTokenSecretKey = f
	return mmRefreshTokenSecretKey.mock
}

// Times sets number of times AuthConfig.RefreshTokenSecretKey should be invoked
func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) Times(n uint64) *mAuthConfigMockRefreshTokenSecretKey {
	if n == 0 {
		mmRefreshTokenSecretKey.mock.t.Fatalf("Times of AuthConfigMock.RefreshTokenSecretKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshTokenSecretKey.expectedInvocations, n)
	return mmRefreshTokenSecretKey
}

func (mmRefreshTokenSecretKey *mAuthConfigMockRefreshTokenSecretKey) invocationsDone() bool {
	if len(mmRefreshTokenSecretKey.expectations) == 0 && mmRefreshTokenSecretKey.defaultExpectation == nil && mmRefreshTokenSecretKey.mock.funcRefreshTokenSecretKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshTokenSecretKey.mock.afterRefreshTokenSecretKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshTokenSecretKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshTokenSecretKey implements config.AuthConfig
func (mmRefreshTokenSecretKey *AuthConfigMock) RefreshTokenSecretKey() (s1 string) {
	mm_atomic.AddUint64(&mmRefreshTokenSecretKey.beforeRefreshTokenSecretKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshTokenSecretKey.afterRefreshTokenSecretKeyCounter, 1)

	if mmRefreshTokenSecretKey.inspectFuncRefreshTokenSecretKey != nil {
		mmRefreshTokenSecretKey.inspectFuncRefreshTokenSecretKey()
	}

	if mmRefreshTokenSecretKey.RefreshTokenSecretKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshTokenSecretKey.RefreshTokenSecretKeyMock.defaultExpectation.Counter, 1)

		mm_results := mmRefreshTokenSecretKey.RefreshTokenSecretKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshTokenSecretKey.t.Fatal("No results are set for the AuthConfigMock.RefreshTokenSecretKey")
		}
		return (*mm_results).s1
	}
	if mmRefreshTokenSecretKey.funcRefreshTokenSecretKey != nil {
		return mmRefreshTokenSecretKey.funcRefreshTokenSecretKey()
	}
	mmRefreshTokenSecretKey.t.Fatalf("Unexpected call to AuthConfigMock.RefreshTokenSecretKey.")
	return
}

// RefreshTokenSecretKeyAfterCounter returns a count of finished AuthConfigMock.RefreshTokenSecretKey invocations
func (mmRefreshTokenSecretKey *AuthConfigMock) RefreshTokenSecretKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokenSecretKey.afterRefreshTokenSecretKeyCounter)
}

// RefreshTokenSecretKeyBeforeCounter returns a count of AuthConfigMock.RefreshTokenSecretKey invocations
func (mmRefreshTokenSecretKey *AuthConfigMock) RefreshTokenSecretKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshTokenSecretKey.beforeRefreshTokenSecretKeyCounter)
}

// MinimockRefreshTokenSecretKeyDone returns true if the count of the RefreshTokenSecretKey invocations corresponds
// the number of defined expectations
func (m *AuthConfigMock) MinimockRefreshTokenSecretKeyDone() bool {
	if m.RefreshTokenSecretKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTokenSecretKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTokenSecretKeyMock.invocationsDone()
}

// MinimockRefreshTokenSecretKeyInspect logs each unmet expectation
func (m *AuthConfigMock) MinimockRefreshTokenSecretKeyInspect() {
	for _, e := range m.RefreshTokenSecretKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AuthConfigMock.RefreshTokenSecretKey")
		}
	}

	afterRefreshTokenSecretKeyCounter := mm_atomic.LoadUint64(&m.afterRefreshTokenSecretKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokenSecretKeyMock.defaultExpectation != nil && afterRefreshTokenSecretKeyCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.RefreshTokenSecretKey")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshTokenSecretKey != nil && afterRefreshTokenSecretKeyCounter < 1 {
		m.t.Error("Expected call to AuthConfigMock.RefreshTokenSecretKey")
	}

	if !m.RefreshTokenSecretKeyMock.invocationsDone() && afterRefreshTokenSecretKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthConfigMock.RefreshTokenSecretKey but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTokenSecretKeyMock.expectedInvocations), afterRefreshTokenSecretKeyCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthConfigMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAccessTokenExpirationInspect()

			m.MinimockAccessTokenSecretKeyInspect()

			m.MinimockRefreshTokenExpirationInspect()

			m.MinimockRefreshTokenSecretKeyInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthConfigMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthConfigMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccessTokenExpirationDone() &&
		m.MinimockAccessTokenSecretKeyDone() &&
		m.MinimockRefreshTokenExpirationDone() &&
		m.MinimockRefreshTokenSecretKeyDone()
}
