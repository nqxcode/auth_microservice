// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/nqxcode/auth_microservice/internal/repository.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/nqxcode/auth_microservice/internal/model"
	"github.com/nqxcode/platform_common/pagination"
)

// UserRepositoryMock implements repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, model *model.User) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, model *model.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserRepositoryMockDelete

	funcExistsWithEmail          func(ctx context.Context, email string) (b1 bool, err error)
	inspectFuncExistsWithEmail   func(ctx context.Context, email string)
	afterExistsWithEmailCounter  uint64
	beforeExistsWithEmailCounter uint64
	ExistsWithEmailMock          mUserRepositoryMockExistsWithEmail

	funcGet          func(ctx context.Context, id int64) (up1 *model.User, err error)
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserRepositoryMockGet

	funcGetByEmail          func(ctx context.Context, email string) (up1 *model.User, err error)
	inspectFuncGetByEmail   func(ctx context.Context, email string)
	afterGetByEmailCounter  uint64
	beforeGetByEmailCounter uint64
	GetByEmailMock          mUserRepositoryMockGetByEmail

	funcGetByIDs          func(ctx context.Context, id []int64) (ua1 []model.User, err error)
	inspectFuncGetByIDs   func(ctx context.Context, id []int64)
	afterGetByIDsCounter  uint64
	beforeGetByIDsCounter uint64
	GetByIDsMock          mUserRepositoryMockGetByIDs

	funcGetList          func(ctx context.Context, limit pagination.Limit) (ua1 []model.User, err error)
	inspectFuncGetList   func(ctx context.Context, limit pagination.Limit)
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mUserRepositoryMockGetList

	funcUpdate          func(ctx context.Context, id int64, info *model.UpdateUserInfo) (err error)
	inspectFuncUpdate   func(ctx context.Context, id int64, info *model.UpdateUserInfo)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserRepositoryMockUpdate
}

// NewUserRepositoryMock returns a mock for repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

	m.DeleteMock = mUserRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

	m.ExistsWithEmailMock = mUserRepositoryMockExistsWithEmail{mock: m}
	m.ExistsWithEmailMock.callArgs = []*UserRepositoryMockExistsWithEmailParams{}

	m.GetMock = mUserRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserRepositoryMockGetParams{}

	m.GetByEmailMock = mUserRepositoryMockGetByEmail{mock: m}
	m.GetByEmailMock.callArgs = []*UserRepositoryMockGetByEmailParams{}

	m.GetByIDsMock = mUserRepositoryMockGetByIDs{mock: m}
	m.GetByIDsMock.callArgs = []*UserRepositoryMockGetByIDsParams{}

	m.GetListMock = mUserRepositoryMockGetList{mock: m}
	m.GetListMock.callArgs = []*UserRepositoryMockGetListParams{}

	m.UpdateMock = mUserRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateExpectation
	expectations       []*UserRepositoryMockCreateExpectation

	callArgs []*UserRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockCreateParams
	paramPtrs *UserRepositoryMockCreateParamPtrs
	results   *UserRepositoryMockCreateResults
	Counter   uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
	ctx   context.Context
	model *model.User
}

// UserRepositoryMockCreateParamPtrs contains pointers to parameters of the UserRepository.Create
type UserRepositoryMockCreateParamPtrs struct {
	ctx   *context.Context
	model **model.User
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserRepositoryMockCreate) Optional() *mUserRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, model *model.User) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserRepositoryMockCreateParams{ctx, model}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectModelParam2 sets up expected param model for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectModelParam2(model *model.User) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.model = &model

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, model *model.User)) *mUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, model *model.User) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, model *model.User) *UserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &UserRepositoryMockCreateParams{ctx, model},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepository.Create should be invoked
func (mmCreate *mUserRepositoryMockCreate) Times(n uint64) *mUserRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mUserRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements repository.UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, model *model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, model)
	}

	mm_params := UserRepositoryMockCreateParams{ctx, model}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateParams{ctx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter model, want: %#v, got: %#v%s\n", *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, model)
	}
	mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v", ctx, model)
	return
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mUserRepositoryMockDelete struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteExpectation
	expectations       []*UserRepositoryMockDeleteExpectation

	callArgs []*UserRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockDeleteParams
	paramPtrs *UserRepositoryMockDeleteParamPtrs
	results   *UserRepositoryMockDeleteResults
	Counter   uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserRepositoryMockDelete) Optional() *mUserRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectIdParam2(id int64) *mUserRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, id int64) *UserRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UserRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Delete should be invoked
func (mmDelete *mUserRepositoryMockDelete) Times(n uint64) *mUserRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mUserRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mUserRepositoryMockExistsWithEmail struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockExistsWithEmailExpectation
	expectations       []*UserRepositoryMockExistsWithEmailExpectation

	callArgs []*UserRepositoryMockExistsWithEmailParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockExistsWithEmailExpectation specifies expectation struct of the UserRepository.ExistsWithEmail
type UserRepositoryMockExistsWithEmailExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockExistsWithEmailParams
	paramPtrs *UserRepositoryMockExistsWithEmailParamPtrs
	results   *UserRepositoryMockExistsWithEmailResults
	Counter   uint64
}

// UserRepositoryMockExistsWithEmailParams contains parameters of the UserRepository.ExistsWithEmail
type UserRepositoryMockExistsWithEmailParams struct {
	ctx   context.Context
	email string
}

// UserRepositoryMockExistsWithEmailParamPtrs contains pointers to parameters of the UserRepository.ExistsWithEmail
type UserRepositoryMockExistsWithEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// UserRepositoryMockExistsWithEmailResults contains results of the UserRepository.ExistsWithEmail
type UserRepositoryMockExistsWithEmailResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Optional() *mUserRepositoryMockExistsWithEmail {
	mmExistsWithEmail.optional = true
	return mmExistsWithEmail
}

// Expect sets up expected params for UserRepository.ExistsWithEmail
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Expect(ctx context.Context, email string) *mUserRepositoryMockExistsWithEmail {
	if mmExistsWithEmail.mock.funcExistsWithEmail != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Set")
	}

	if mmExistsWithEmail.defaultExpectation == nil {
		mmExistsWithEmail.defaultExpectation = &UserRepositoryMockExistsWithEmailExpectation{}
	}

	if mmExistsWithEmail.defaultExpectation.paramPtrs != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by ExpectParams functions")
	}

	mmExistsWithEmail.defaultExpectation.params = &UserRepositoryMockExistsWithEmailParams{ctx, email}
	for _, e := range mmExistsWithEmail.expectations {
		if minimock.Equal(e.params, mmExistsWithEmail.defaultExpectation.params) {
			mmExistsWithEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExistsWithEmail.defaultExpectation.params)
		}
	}

	return mmExistsWithEmail
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.ExistsWithEmail
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockExistsWithEmail {
	if mmExistsWithEmail.mock.funcExistsWithEmail != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Set")
	}

	if mmExistsWithEmail.defaultExpectation == nil {
		mmExistsWithEmail.defaultExpectation = &UserRepositoryMockExistsWithEmailExpectation{}
	}

	if mmExistsWithEmail.defaultExpectation.params != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Expect")
	}

	if mmExistsWithEmail.defaultExpectation.paramPtrs == nil {
		mmExistsWithEmail.defaultExpectation.paramPtrs = &UserRepositoryMockExistsWithEmailParamPtrs{}
	}
	mmExistsWithEmail.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExistsWithEmail
}

// ExpectEmailParam2 sets up expected param email for UserRepository.ExistsWithEmail
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) ExpectEmailParam2(email string) *mUserRepositoryMockExistsWithEmail {
	if mmExistsWithEmail.mock.funcExistsWithEmail != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Set")
	}

	if mmExistsWithEmail.defaultExpectation == nil {
		mmExistsWithEmail.defaultExpectation = &UserRepositoryMockExistsWithEmailExpectation{}
	}

	if mmExistsWithEmail.defaultExpectation.params != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Expect")
	}

	if mmExistsWithEmail.defaultExpectation.paramPtrs == nil {
		mmExistsWithEmail.defaultExpectation.paramPtrs = &UserRepositoryMockExistsWithEmailParamPtrs{}
	}
	mmExistsWithEmail.defaultExpectation.paramPtrs.email = &email

	return mmExistsWithEmail
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.ExistsWithEmail
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Inspect(f func(ctx context.Context, email string)) *mUserRepositoryMockExistsWithEmail {
	if mmExistsWithEmail.mock.inspectFuncExistsWithEmail != nil {
		mmExistsWithEmail.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.ExistsWithEmail")
	}

	mmExistsWithEmail.mock.inspectFuncExistsWithEmail = f

	return mmExistsWithEmail
}

// Return sets up results that will be returned by UserRepository.ExistsWithEmail
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Return(b1 bool, err error) *UserRepositoryMock {
	if mmExistsWithEmail.mock.funcExistsWithEmail != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Set")
	}

	if mmExistsWithEmail.defaultExpectation == nil {
		mmExistsWithEmail.defaultExpectation = &UserRepositoryMockExistsWithEmailExpectation{mock: mmExistsWithEmail.mock}
	}
	mmExistsWithEmail.defaultExpectation.results = &UserRepositoryMockExistsWithEmailResults{b1, err}
	return mmExistsWithEmail.mock
}

// Set uses given function f to mock the UserRepository.ExistsWithEmail method
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Set(f func(ctx context.Context, email string) (b1 bool, err error)) *UserRepositoryMock {
	if mmExistsWithEmail.defaultExpectation != nil {
		mmExistsWithEmail.mock.t.Fatalf("Default expectation is already set for the UserRepository.ExistsWithEmail method")
	}

	if len(mmExistsWithEmail.expectations) > 0 {
		mmExistsWithEmail.mock.t.Fatalf("Some expectations are already set for the UserRepository.ExistsWithEmail method")
	}

	mmExistsWithEmail.mock.funcExistsWithEmail = f
	return mmExistsWithEmail.mock
}

// When sets expectation for the UserRepository.ExistsWithEmail which will trigger the result defined by the following
// Then helper
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) When(ctx context.Context, email string) *UserRepositoryMockExistsWithEmailExpectation {
	if mmExistsWithEmail.mock.funcExistsWithEmail != nil {
		mmExistsWithEmail.mock.t.Fatalf("UserRepositoryMock.ExistsWithEmail mock is already set by Set")
	}

	expectation := &UserRepositoryMockExistsWithEmailExpectation{
		mock:   mmExistsWithEmail.mock,
		params: &UserRepositoryMockExistsWithEmailParams{ctx, email},
	}
	mmExistsWithEmail.expectations = append(mmExistsWithEmail.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.ExistsWithEmail return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockExistsWithEmailExpectation) Then(b1 bool, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockExistsWithEmailResults{b1, err}
	return e.mock
}

// Times sets number of times UserRepository.ExistsWithEmail should be invoked
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Times(n uint64) *mUserRepositoryMockExistsWithEmail {
	if n == 0 {
		mmExistsWithEmail.mock.t.Fatalf("Times of UserRepositoryMock.ExistsWithEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExistsWithEmail.expectedInvocations, n)
	return mmExistsWithEmail
}

func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) invocationsDone() bool {
	if len(mmExistsWithEmail.expectations) == 0 && mmExistsWithEmail.defaultExpectation == nil && mmExistsWithEmail.mock.funcExistsWithEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExistsWithEmail.mock.afterExistsWithEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExistsWithEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExistsWithEmail implements repository.UserRepository
func (mmExistsWithEmail *UserRepositoryMock) ExistsWithEmail(ctx context.Context, email string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmExistsWithEmail.beforeExistsWithEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmExistsWithEmail.afterExistsWithEmailCounter, 1)

	if mmExistsWithEmail.inspectFuncExistsWithEmail != nil {
		mmExistsWithEmail.inspectFuncExistsWithEmail(ctx, email)
	}

	mm_params := UserRepositoryMockExistsWithEmailParams{ctx, email}

	// Record call args
	mmExistsWithEmail.ExistsWithEmailMock.mutex.Lock()
	mmExistsWithEmail.ExistsWithEmailMock.callArgs = append(mmExistsWithEmail.ExistsWithEmailMock.callArgs, &mm_params)
	mmExistsWithEmail.ExistsWithEmailMock.mutex.Unlock()

	for _, e := range mmExistsWithEmail.ExistsWithEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmExistsWithEmail.ExistsWithEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExistsWithEmail.ExistsWithEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmExistsWithEmail.ExistsWithEmailMock.defaultExpectation.params
		mm_want_ptrs := mmExistsWithEmail.ExistsWithEmailMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockExistsWithEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExistsWithEmail.t.Errorf("UserRepositoryMock.ExistsWithEmail got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmExistsWithEmail.t.Errorf("UserRepositoryMock.ExistsWithEmail got unexpected parameter email, want: %#v, got: %#v%s\n", *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExistsWithEmail.t.Errorf("UserRepositoryMock.ExistsWithEmail got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExistsWithEmail.ExistsWithEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmExistsWithEmail.t.Fatal("No results are set for the UserRepositoryMock.ExistsWithEmail")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmExistsWithEmail.funcExistsWithEmail != nil {
		return mmExistsWithEmail.funcExistsWithEmail(ctx, email)
	}
	mmExistsWithEmail.t.Fatalf("Unexpected call to UserRepositoryMock.ExistsWithEmail. %v %v", ctx, email)
	return
}

// ExistsWithEmailAfterCounter returns a count of finished UserRepositoryMock.ExistsWithEmail invocations
func (mmExistsWithEmail *UserRepositoryMock) ExistsWithEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExistsWithEmail.afterExistsWithEmailCounter)
}

// ExistsWithEmailBeforeCounter returns a count of UserRepositoryMock.ExistsWithEmail invocations
func (mmExistsWithEmail *UserRepositoryMock) ExistsWithEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExistsWithEmail.beforeExistsWithEmailCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.ExistsWithEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExistsWithEmail *mUserRepositoryMockExistsWithEmail) Calls() []*UserRepositoryMockExistsWithEmailParams {
	mmExistsWithEmail.mutex.RLock()

	argCopy := make([]*UserRepositoryMockExistsWithEmailParams, len(mmExistsWithEmail.callArgs))
	copy(argCopy, mmExistsWithEmail.callArgs)

	mmExistsWithEmail.mutex.RUnlock()

	return argCopy
}

// MinimockExistsWithEmailDone returns true if the count of the ExistsWithEmail invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockExistsWithEmailDone() bool {
	if m.ExistsWithEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExistsWithEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExistsWithEmailMock.invocationsDone()
}

// MinimockExistsWithEmailInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockExistsWithEmailInspect() {
	for _, e := range m.ExistsWithEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.ExistsWithEmail with params: %#v", *e.params)
		}
	}

	afterExistsWithEmailCounter := mm_atomic.LoadUint64(&m.afterExistsWithEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExistsWithEmailMock.defaultExpectation != nil && afterExistsWithEmailCounter < 1 {
		if m.ExistsWithEmailMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.ExistsWithEmail")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.ExistsWithEmail with params: %#v", *m.ExistsWithEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExistsWithEmail != nil && afterExistsWithEmailCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.ExistsWithEmail")
	}

	if !m.ExistsWithEmailMock.invocationsDone() && afterExistsWithEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.ExistsWithEmail but found %d calls",
			mm_atomic.LoadUint64(&m.ExistsWithEmailMock.expectedInvocations), afterExistsWithEmailCounter)
	}
}

type mUserRepositoryMockGet struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetExpectation
	expectations       []*UserRepositoryMockGetExpectation

	callArgs []*UserRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockGetExpectation specifies expectation struct of the UserRepository.Get
type UserRepositoryMockGetExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockGetParams
	paramPtrs *UserRepositoryMockGetParamPtrs
	results   *UserRepositoryMockGetResults
	Counter   uint64
}

// UserRepositoryMockGetParams contains parameters of the UserRepository.Get
type UserRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryMockGetParamPtrs contains pointers to parameters of the UserRepository.Get
type UserRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryMockGetResults contains results of the UserRepository.Get
type UserRepositoryMockGetResults struct {
	up1 *model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserRepositoryMockGet) Optional() *mUserRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Expect(ctx context.Context, id int64) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserRepositoryMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectIdParam2(id int64) *mUserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Return(up1 *model.User, err error) *UserRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserRepositoryMockGetResults{up1, err}
	return mmGet.mock
}

// Set uses given function f to mock the UserRepository.Get method
func (mmGet *mUserRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *UserRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the UserRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserRepositoryMockGet) When(ctx context.Context, id int64) *UserRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &UserRepositoryMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetExpectation) Then(up1 *model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.Get should be invoked
func (mmGet *mUserRepositoryMockGet) Times(n uint64) *mUserRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mUserRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements repository.UserRepository
func (mmGet *UserRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserRepositoryMockGet) Calls() []*UserRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

type mUserRepositoryMockGetByEmail struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetByEmailExpectation
	expectations       []*UserRepositoryMockGetByEmailExpectation

	callArgs []*UserRepositoryMockGetByEmailParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockGetByEmailExpectation specifies expectation struct of the UserRepository.GetByEmail
type UserRepositoryMockGetByEmailExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockGetByEmailParams
	paramPtrs *UserRepositoryMockGetByEmailParamPtrs
	results   *UserRepositoryMockGetByEmailResults
	Counter   uint64
}

// UserRepositoryMockGetByEmailParams contains parameters of the UserRepository.GetByEmail
type UserRepositoryMockGetByEmailParams struct {
	ctx   context.Context
	email string
}

// UserRepositoryMockGetByEmailParamPtrs contains pointers to parameters of the UserRepository.GetByEmail
type UserRepositoryMockGetByEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// UserRepositoryMockGetByEmailResults contains results of the UserRepository.GetByEmail
type UserRepositoryMockGetByEmailResults struct {
	up1 *model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Optional() *mUserRepositoryMockGetByEmail {
	mmGetByEmail.optional = true
	return mmGetByEmail
}

// Expect sets up expected params for UserRepository.GetByEmail
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Expect(ctx context.Context, email string) *mUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &UserRepositoryMockGetByEmailExpectation{}
	}

	if mmGetByEmail.defaultExpectation.paramPtrs != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by ExpectParams functions")
	}

	mmGetByEmail.defaultExpectation.params = &UserRepositoryMockGetByEmailParams{ctx, email}
	for _, e := range mmGetByEmail.expectations {
		if minimock.Equal(e.params, mmGetByEmail.defaultExpectation.params) {
			mmGetByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByEmail.defaultExpectation.params)
		}
	}

	return mmGetByEmail
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetByEmail
func (mmGetByEmail *mUserRepositoryMockGetByEmail) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &UserRepositoryMockGetByEmailExpectation{}
	}

	if mmGetByEmail.defaultExpectation.params != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Expect")
	}

	if mmGetByEmail.defaultExpectation.paramPtrs == nil {
		mmGetByEmail.defaultExpectation.paramPtrs = &UserRepositoryMockGetByEmailParamPtrs{}
	}
	mmGetByEmail.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetByEmail
}

// ExpectEmailParam2 sets up expected param email for UserRepository.GetByEmail
func (mmGetByEmail *mUserRepositoryMockGetByEmail) ExpectEmailParam2(email string) *mUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &UserRepositoryMockGetByEmailExpectation{}
	}

	if mmGetByEmail.defaultExpectation.params != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Expect")
	}

	if mmGetByEmail.defaultExpectation.paramPtrs == nil {
		mmGetByEmail.defaultExpectation.paramPtrs = &UserRepositoryMockGetByEmailParamPtrs{}
	}
	mmGetByEmail.defaultExpectation.paramPtrs.email = &email

	return mmGetByEmail
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetByEmail
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Inspect(f func(ctx context.Context, email string)) *mUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.inspectFuncGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetByEmail")
	}

	mmGetByEmail.mock.inspectFuncGetByEmail = f

	return mmGetByEmail
}

// Return sets up results that will be returned by UserRepository.GetByEmail
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Return(up1 *model.User, err error) *UserRepositoryMock {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &UserRepositoryMockGetByEmailExpectation{mock: mmGetByEmail.mock}
	}
	mmGetByEmail.defaultExpectation.results = &UserRepositoryMockGetByEmailResults{up1, err}
	return mmGetByEmail.mock
}

// Set uses given function f to mock the UserRepository.GetByEmail method
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Set(f func(ctx context.Context, email string) (up1 *model.User, err error)) *UserRepositoryMock {
	if mmGetByEmail.defaultExpectation != nil {
		mmGetByEmail.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetByEmail method")
	}

	if len(mmGetByEmail.expectations) > 0 {
		mmGetByEmail.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetByEmail method")
	}

	mmGetByEmail.mock.funcGetByEmail = f
	return mmGetByEmail.mock
}

// When sets expectation for the UserRepository.GetByEmail which will trigger the result defined by the following
// Then helper
func (mmGetByEmail *mUserRepositoryMockGetByEmail) When(ctx context.Context, email string) *UserRepositoryMockGetByEmailExpectation {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("UserRepositoryMock.GetByEmail mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetByEmailExpectation{
		mock:   mmGetByEmail.mock,
		params: &UserRepositoryMockGetByEmailParams{ctx, email},
	}
	mmGetByEmail.expectations = append(mmGetByEmail.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetByEmail return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetByEmailExpectation) Then(up1 *model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetByEmailResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetByEmail should be invoked
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Times(n uint64) *mUserRepositoryMockGetByEmail {
	if n == 0 {
		mmGetByEmail.mock.t.Fatalf("Times of UserRepositoryMock.GetByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByEmail.expectedInvocations, n)
	return mmGetByEmail
}

func (mmGetByEmail *mUserRepositoryMockGetByEmail) invocationsDone() bool {
	if len(mmGetByEmail.expectations) == 0 && mmGetByEmail.defaultExpectation == nil && mmGetByEmail.mock.funcGetByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByEmail.mock.afterGetByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByEmail implements repository.UserRepository
func (mmGetByEmail *UserRepositoryMock) GetByEmail(ctx context.Context, email string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetByEmail.beforeGetByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByEmail.afterGetByEmailCounter, 1)

	if mmGetByEmail.inspectFuncGetByEmail != nil {
		mmGetByEmail.inspectFuncGetByEmail(ctx, email)
	}

	mm_params := UserRepositoryMockGetByEmailParams{ctx, email}

	// Record call args
	mmGetByEmail.GetByEmailMock.mutex.Lock()
	mmGetByEmail.GetByEmailMock.callArgs = append(mmGetByEmail.GetByEmailMock.callArgs, &mm_params)
	mmGetByEmail.GetByEmailMock.mutex.Unlock()

	for _, e := range mmGetByEmail.GetByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetByEmail.GetByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByEmail.GetByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByEmail.GetByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetByEmail.GetByEmailMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetByEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByEmail.t.Errorf("UserRepositoryMock.GetByEmail got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetByEmail.t.Errorf("UserRepositoryMock.GetByEmail got unexpected parameter email, want: %#v, got: %#v%s\n", *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByEmail.t.Errorf("UserRepositoryMock.GetByEmail got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByEmail.GetByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByEmail.t.Fatal("No results are set for the UserRepositoryMock.GetByEmail")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetByEmail.funcGetByEmail != nil {
		return mmGetByEmail.funcGetByEmail(ctx, email)
	}
	mmGetByEmail.t.Fatalf("Unexpected call to UserRepositoryMock.GetByEmail. %v %v", ctx, email)
	return
}

// GetByEmailAfterCounter returns a count of finished UserRepositoryMock.GetByEmail invocations
func (mmGetByEmail *UserRepositoryMock) GetByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByEmail.afterGetByEmailCounter)
}

// GetByEmailBeforeCounter returns a count of UserRepositoryMock.GetByEmail invocations
func (mmGetByEmail *UserRepositoryMock) GetByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByEmail.beforeGetByEmailCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByEmail *mUserRepositoryMockGetByEmail) Calls() []*UserRepositoryMockGetByEmailParams {
	mmGetByEmail.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetByEmailParams, len(mmGetByEmail.callArgs))
	copy(argCopy, mmGetByEmail.callArgs)

	mmGetByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetByEmailDone returns true if the count of the GetByEmail invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetByEmailDone() bool {
	if m.GetByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByEmailMock.invocationsDone()
}

// MinimockGetByEmailInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetByEmailInspect() {
	for _, e := range m.GetByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetByEmail with params: %#v", *e.params)
		}
	}

	afterGetByEmailCounter := mm_atomic.LoadUint64(&m.afterGetByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByEmailMock.defaultExpectation != nil && afterGetByEmailCounter < 1 {
		if m.GetByEmailMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetByEmail")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetByEmail with params: %#v", *m.GetByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByEmail != nil && afterGetByEmailCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetByEmail")
	}

	if !m.GetByEmailMock.invocationsDone() && afterGetByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetByEmail but found %d calls",
			mm_atomic.LoadUint64(&m.GetByEmailMock.expectedInvocations), afterGetByEmailCounter)
	}
}

type mUserRepositoryMockGetByIDs struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetByIDsExpectation
	expectations       []*UserRepositoryMockGetByIDsExpectation

	callArgs []*UserRepositoryMockGetByIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockGetByIDsExpectation specifies expectation struct of the UserRepository.GetByIDs
type UserRepositoryMockGetByIDsExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockGetByIDsParams
	paramPtrs *UserRepositoryMockGetByIDsParamPtrs
	results   *UserRepositoryMockGetByIDsResults
	Counter   uint64
}

// UserRepositoryMockGetByIDsParams contains parameters of the UserRepository.GetByIDs
type UserRepositoryMockGetByIDsParams struct {
	ctx context.Context
	id  []int64
}

// UserRepositoryMockGetByIDsParamPtrs contains pointers to parameters of the UserRepository.GetByIDs
type UserRepositoryMockGetByIDsParamPtrs struct {
	ctx *context.Context
	id  *[]int64
}

// UserRepositoryMockGetByIDsResults contains results of the UserRepository.GetByIDs
type UserRepositoryMockGetByIDsResults struct {
	ua1 []model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Optional() *mUserRepositoryMockGetByIDs {
	mmGetByIDs.optional = true
	return mmGetByIDs
}

// Expect sets up expected params for UserRepository.GetByIDs
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Expect(ctx context.Context, id []int64) *mUserRepositoryMockGetByIDs {
	if mmGetByIDs.mock.funcGetByIDs != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Set")
	}

	if mmGetByIDs.defaultExpectation == nil {
		mmGetByIDs.defaultExpectation = &UserRepositoryMockGetByIDsExpectation{}
	}

	if mmGetByIDs.defaultExpectation.paramPtrs != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by ExpectParams functions")
	}

	mmGetByIDs.defaultExpectation.params = &UserRepositoryMockGetByIDsParams{ctx, id}
	for _, e := range mmGetByIDs.expectations {
		if minimock.Equal(e.params, mmGetByIDs.defaultExpectation.params) {
			mmGetByIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByIDs.defaultExpectation.params)
		}
	}

	return mmGetByIDs
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetByIDs
func (mmGetByIDs *mUserRepositoryMockGetByIDs) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetByIDs {
	if mmGetByIDs.mock.funcGetByIDs != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Set")
	}

	if mmGetByIDs.defaultExpectation == nil {
		mmGetByIDs.defaultExpectation = &UserRepositoryMockGetByIDsExpectation{}
	}

	if mmGetByIDs.defaultExpectation.params != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Expect")
	}

	if mmGetByIDs.defaultExpectation.paramPtrs == nil {
		mmGetByIDs.defaultExpectation.paramPtrs = &UserRepositoryMockGetByIDsParamPtrs{}
	}
	mmGetByIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetByIDs
}

// ExpectIdParam2 sets up expected param id for UserRepository.GetByIDs
func (mmGetByIDs *mUserRepositoryMockGetByIDs) ExpectIdParam2(id []int64) *mUserRepositoryMockGetByIDs {
	if mmGetByIDs.mock.funcGetByIDs != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Set")
	}

	if mmGetByIDs.defaultExpectation == nil {
		mmGetByIDs.defaultExpectation = &UserRepositoryMockGetByIDsExpectation{}
	}

	if mmGetByIDs.defaultExpectation.params != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Expect")
	}

	if mmGetByIDs.defaultExpectation.paramPtrs == nil {
		mmGetByIDs.defaultExpectation.paramPtrs = &UserRepositoryMockGetByIDsParamPtrs{}
	}
	mmGetByIDs.defaultExpectation.paramPtrs.id = &id

	return mmGetByIDs
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetByIDs
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Inspect(f func(ctx context.Context, id []int64)) *mUserRepositoryMockGetByIDs {
	if mmGetByIDs.mock.inspectFuncGetByIDs != nil {
		mmGetByIDs.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetByIDs")
	}

	mmGetByIDs.mock.inspectFuncGetByIDs = f

	return mmGetByIDs
}

// Return sets up results that will be returned by UserRepository.GetByIDs
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Return(ua1 []model.User, err error) *UserRepositoryMock {
	if mmGetByIDs.mock.funcGetByIDs != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Set")
	}

	if mmGetByIDs.defaultExpectation == nil {
		mmGetByIDs.defaultExpectation = &UserRepositoryMockGetByIDsExpectation{mock: mmGetByIDs.mock}
	}
	mmGetByIDs.defaultExpectation.results = &UserRepositoryMockGetByIDsResults{ua1, err}
	return mmGetByIDs.mock
}

// Set uses given function f to mock the UserRepository.GetByIDs method
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Set(f func(ctx context.Context, id []int64) (ua1 []model.User, err error)) *UserRepositoryMock {
	if mmGetByIDs.defaultExpectation != nil {
		mmGetByIDs.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetByIDs method")
	}

	if len(mmGetByIDs.expectations) > 0 {
		mmGetByIDs.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetByIDs method")
	}

	mmGetByIDs.mock.funcGetByIDs = f
	return mmGetByIDs.mock
}

// When sets expectation for the UserRepository.GetByIDs which will trigger the result defined by the following
// Then helper
func (mmGetByIDs *mUserRepositoryMockGetByIDs) When(ctx context.Context, id []int64) *UserRepositoryMockGetByIDsExpectation {
	if mmGetByIDs.mock.funcGetByIDs != nil {
		mmGetByIDs.mock.t.Fatalf("UserRepositoryMock.GetByIDs mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetByIDsExpectation{
		mock:   mmGetByIDs.mock,
		params: &UserRepositoryMockGetByIDsParams{ctx, id},
	}
	mmGetByIDs.expectations = append(mmGetByIDs.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetByIDs return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetByIDsExpectation) Then(ua1 []model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetByIDsResults{ua1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetByIDs should be invoked
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Times(n uint64) *mUserRepositoryMockGetByIDs {
	if n == 0 {
		mmGetByIDs.mock.t.Fatalf("Times of UserRepositoryMock.GetByIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByIDs.expectedInvocations, n)
	return mmGetByIDs
}

func (mmGetByIDs *mUserRepositoryMockGetByIDs) invocationsDone() bool {
	if len(mmGetByIDs.expectations) == 0 && mmGetByIDs.defaultExpectation == nil && mmGetByIDs.mock.funcGetByIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByIDs.mock.afterGetByIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByIDs implements repository.UserRepository
func (mmGetByIDs *UserRepositoryMock) GetByIDs(ctx context.Context, id []int64) (ua1 []model.User, err error) {
	mm_atomic.AddUint64(&mmGetByIDs.beforeGetByIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByIDs.afterGetByIDsCounter, 1)

	if mmGetByIDs.inspectFuncGetByIDs != nil {
		mmGetByIDs.inspectFuncGetByIDs(ctx, id)
	}

	mm_params := UserRepositoryMockGetByIDsParams{ctx, id}

	// Record call args
	mmGetByIDs.GetByIDsMock.mutex.Lock()
	mmGetByIDs.GetByIDsMock.callArgs = append(mmGetByIDs.GetByIDsMock.callArgs, &mm_params)
	mmGetByIDs.GetByIDsMock.mutex.Unlock()

	for _, e := range mmGetByIDs.GetByIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetByIDs.GetByIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByIDs.GetByIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByIDs.GetByIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetByIDs.GetByIDsMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetByIDsParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByIDs.t.Errorf("UserRepositoryMock.GetByIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetByIDs.t.Errorf("UserRepositoryMock.GetByIDs got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByIDs.t.Errorf("UserRepositoryMock.GetByIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByIDs.GetByIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByIDs.t.Fatal("No results are set for the UserRepositoryMock.GetByIDs")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetByIDs.funcGetByIDs != nil {
		return mmGetByIDs.funcGetByIDs(ctx, id)
	}
	mmGetByIDs.t.Fatalf("Unexpected call to UserRepositoryMock.GetByIDs. %v %v", ctx, id)
	return
}

// GetByIDsAfterCounter returns a count of finished UserRepositoryMock.GetByIDs invocations
func (mmGetByIDs *UserRepositoryMock) GetByIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByIDs.afterGetByIDsCounter)
}

// GetByIDsBeforeCounter returns a count of UserRepositoryMock.GetByIDs invocations
func (mmGetByIDs *UserRepositoryMock) GetByIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByIDs.beforeGetByIDsCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetByIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByIDs *mUserRepositoryMockGetByIDs) Calls() []*UserRepositoryMockGetByIDsParams {
	mmGetByIDs.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetByIDsParams, len(mmGetByIDs.callArgs))
	copy(argCopy, mmGetByIDs.callArgs)

	mmGetByIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDsDone returns true if the count of the GetByIDs invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetByIDsDone() bool {
	if m.GetByIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDsMock.invocationsDone()
}

// MinimockGetByIDsInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetByIDsInspect() {
	for _, e := range m.GetByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetByIDs with params: %#v", *e.params)
		}
	}

	afterGetByIDsCounter := mm_atomic.LoadUint64(&m.afterGetByIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDsMock.defaultExpectation != nil && afterGetByIDsCounter < 1 {
		if m.GetByIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetByIDs")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetByIDs with params: %#v", *m.GetByIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByIDs != nil && afterGetByIDsCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetByIDs")
	}

	if !m.GetByIDsMock.invocationsDone() && afterGetByIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetByIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDsMock.expectedInvocations), afterGetByIDsCounter)
	}
}

type mUserRepositoryMockGetList struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetListExpectation
	expectations       []*UserRepositoryMockGetListExpectation

	callArgs []*UserRepositoryMockGetListParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockGetListExpectation specifies expectation struct of the UserRepository.GetList
type UserRepositoryMockGetListExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockGetListParams
	paramPtrs *UserRepositoryMockGetListParamPtrs
	results   *UserRepositoryMockGetListResults
	Counter   uint64
}

// UserRepositoryMockGetListParams contains parameters of the UserRepository.GetList
type UserRepositoryMockGetListParams struct {
	ctx   context.Context
	limit pagination.Limit
}

// UserRepositoryMockGetListParamPtrs contains pointers to parameters of the UserRepository.GetList
type UserRepositoryMockGetListParamPtrs struct {
	ctx   *context.Context
	limit *pagination.Limit
}

// UserRepositoryMockGetListResults contains results of the UserRepository.GetList
type UserRepositoryMockGetListResults struct {
	ua1 []model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetList *mUserRepositoryMockGetList) Optional() *mUserRepositoryMockGetList {
	mmGetList.optional = true
	return mmGetList
}

// Expect sets up expected params for UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) Expect(ctx context.Context, limit pagination.Limit) *mUserRepositoryMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &UserRepositoryMockGetListExpectation{}
	}

	if mmGetList.defaultExpectation.paramPtrs != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by ExpectParams functions")
	}

	mmGetList.defaultExpectation.params = &UserRepositoryMockGetListParams{ctx, limit}
	for _, e := range mmGetList.expectations {
		if minimock.Equal(e.params, mmGetList.defaultExpectation.params) {
			mmGetList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetList.defaultExpectation.params)
		}
	}

	return mmGetList
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &UserRepositoryMockGetListExpectation{}
	}

	if mmGetList.defaultExpectation.params != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Expect")
	}

	if mmGetList.defaultExpectation.paramPtrs == nil {
		mmGetList.defaultExpectation.paramPtrs = &UserRepositoryMockGetListParamPtrs{}
	}
	mmGetList.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetList
}

// ExpectLimitParam2 sets up expected param limit for UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) ExpectLimitParam2(limit pagination.Limit) *mUserRepositoryMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &UserRepositoryMockGetListExpectation{}
	}

	if mmGetList.defaultExpectation.params != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Expect")
	}

	if mmGetList.defaultExpectation.paramPtrs == nil {
		mmGetList.defaultExpectation.paramPtrs = &UserRepositoryMockGetListParamPtrs{}
	}
	mmGetList.defaultExpectation.paramPtrs.limit = &limit

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) Inspect(f func(ctx context.Context, limit pagination.Limit)) *mUserRepositoryMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) Return(ua1 []model.User, err error) *UserRepositoryMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &UserRepositoryMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &UserRepositoryMockGetListResults{ua1, err}
	return mmGetList.mock
}

// Set uses given function f to mock the UserRepository.GetList method
func (mmGetList *mUserRepositoryMockGetList) Set(f func(ctx context.Context, limit pagination.Limit) (ua1 []model.User, err error)) *UserRepositoryMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// When sets expectation for the UserRepository.GetList which will trigger the result defined by the following
// Then helper
func (mmGetList *mUserRepositoryMockGetList) When(ctx context.Context, limit pagination.Limit) *UserRepositoryMockGetListExpectation {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetListExpectation{
		mock:   mmGetList.mock,
		params: &UserRepositoryMockGetListParams{ctx, limit},
	}
	mmGetList.expectations = append(mmGetList.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetList return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetListExpectation) Then(ua1 []model.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetListResults{ua1, err}
	return e.mock
}

// Times sets number of times UserRepository.GetList should be invoked
func (mmGetList *mUserRepositoryMockGetList) Times(n uint64) *mUserRepositoryMockGetList {
	if n == 0 {
		mmGetList.mock.t.Fatalf("Times of UserRepositoryMock.GetList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetList.expectedInvocations, n)
	return mmGetList
}

func (mmGetList *mUserRepositoryMockGetList) invocationsDone() bool {
	if len(mmGetList.expectations) == 0 && mmGetList.defaultExpectation == nil && mmGetList.mock.funcGetList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetList.mock.afterGetListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetList implements repository.UserRepository
func (mmGetList *UserRepositoryMock) GetList(ctx context.Context, limit pagination.Limit) (ua1 []model.User, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList(ctx, limit)
	}

	mm_params := UserRepositoryMockGetListParams{ctx, limit}

	// Record call args
	mmGetList.GetListMock.mutex.Lock()
	mmGetList.GetListMock.callArgs = append(mmGetList.GetListMock.callArgs, &mm_params)
	mmGetList.GetListMock.mutex.Unlock()

	for _, e := range mmGetList.GetListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetList.GetListMock.defaultExpectation.params
		mm_want_ptrs := mmGetList.GetListMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetListParams{ctx, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetList.t.Errorf("UserRepositoryMock.GetList got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetList.t.Errorf("UserRepositoryMock.GetList got unexpected parameter limit, want: %#v, got: %#v%s\n", *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetList.t.Errorf("UserRepositoryMock.GetList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the UserRepositoryMock.GetList")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList(ctx, limit)
	}
	mmGetList.t.Fatalf("Unexpected call to UserRepositoryMock.GetList. %v %v", ctx, limit)
	return
}

// GetListAfterCounter returns a count of finished UserRepositoryMock.GetList invocations
func (mmGetList *UserRepositoryMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of UserRepositoryMock.GetList invocations
func (mmGetList *UserRepositoryMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetList *mUserRepositoryMockGetList) Calls() []*UserRepositoryMockGetListParams {
	mmGetList.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetListParams, len(mmGetList.callArgs))
	copy(argCopy, mmGetList.callArgs)

	mmGetList.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetListDone() bool {
	if m.GetListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListMock.invocationsDone()
}

// MinimockGetListInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetList with params: %#v", *e.params)
		}
	}

	afterGetListCounter := mm_atomic.LoadUint64(&m.afterGetListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && afterGetListCounter < 1 {
		if m.GetListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetList")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetList with params: %#v", *m.GetListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && afterGetListCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetList")
	}

	if !m.GetListMock.invocationsDone() && afterGetListCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetList but found %d calls",
			mm_atomic.LoadUint64(&m.GetListMock.expectedInvocations), afterGetListCounter)
	}
}

type mUserRepositoryMockUpdate struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockUpdateExpectation
	expectations       []*UserRepositoryMockUpdateExpectation

	callArgs []*UserRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockUpdateExpectation specifies expectation struct of the UserRepository.Update
type UserRepositoryMockUpdateExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockUpdateParams
	paramPtrs *UserRepositoryMockUpdateParamPtrs
	results   *UserRepositoryMockUpdateResults
	Counter   uint64
}

// UserRepositoryMockUpdateParams contains parameters of the UserRepository.Update
type UserRepositoryMockUpdateParams struct {
	ctx  context.Context
	id   int64
	info *model.UpdateUserInfo
}

// UserRepositoryMockUpdateParamPtrs contains pointers to parameters of the UserRepository.Update
type UserRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	id   *int64
	info **model.UpdateUserInfo
}

// UserRepositoryMockUpdateResults contains results of the UserRepository.Update
type UserRepositoryMockUpdateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUserRepositoryMockUpdate) Optional() *mUserRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Expect(ctx context.Context, id int64, info *model.UpdateUserInfo) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UserRepositoryMockUpdateParams{ctx, id, info}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectIdParam2(id int64) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id

	return mmUpdate
}

// ExpectInfoParam3 sets up expected param info for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectInfoParam3(info *model.UpdateUserInfo) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.info = &info

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, info *model.UpdateUserInfo)) *mUserRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Return(err error) *UserRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the UserRepository.Update method
func (mmUpdate *mUserRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, info *model.UpdateUserInfo) (err error)) *UserRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the UserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserRepositoryMockUpdate) When(ctx context.Context, id int64, info *model.UpdateUserInfo) *UserRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UserRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &UserRepositoryMockUpdateParams{ctx, id, info},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times UserRepository.Update should be invoked
func (mmUpdate *mUserRepositoryMockUpdate) Times(n uint64) *mUserRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UserRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	return mmUpdate
}

func (mmUpdate *mUserRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements repository.UserRepository
func (mmUpdate *UserRepositoryMock) Update(ctx context.Context, id int64, info *model.UpdateUserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, info)
	}

	mm_params := UserRepositoryMockUpdateParams{ctx, id, info}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockUpdateParams{ctx, id, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter info, want: %#v, got: %#v%s\n", *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, info)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserRepositoryMock.Update. %v %v %v", ctx, id, info)
	return
}

// UpdateAfterCounter returns a count of finished UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserRepositoryMockUpdate) Calls() []*UserRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Update")
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.Update but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockExistsWithEmailInspect()

			m.MinimockGetInspect()

			m.MinimockGetByEmailInspect()

			m.MinimockGetByIDsInspect()

			m.MinimockGetListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockExistsWithEmailDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetByEmailDone() &&
		m.MinimockGetByIDsDone() &&
		m.MinimockGetListDone() &&
		m.MinimockUpdateDone()
}
